//
//  functioninterface.c
//  O_All
//
//  Created by YXCD on 13-9-11.
//  Copyright (c) 2013年 YXCD. All rights reserved.
//


#include "func_def.h"
#include "type_def.h"
#include "O_All.h"
#include "comm_def.h"
#include "GTMbase64.h"

#include "prtypes.h"
#include "protypes.h"
#include "certt.h"
#include "pk11pub.h"
#include "cert.h"
#include "nss.h"
#include "keyhi.h"
#include "cryptohi.h"
#include "sechash.h"
#include "secpkcs7.h"
#include "secport.h"
#include "p12plcy.h"
#include "p12.h"
#include "prinit.h"
#include "secerr.h"
#include "prerror.h"
#include "blapi.h"
#include "certdb.h"
#include "SM3_Endian.h"

#include "UserAPIServiceSvc.h"


#define UserAPIService_AA_MODEL 1

//NSSBase64_EncodeItem
//NSSBase64_DecodeBuffer

static char s_user_pin_data[256];
static bool s_user_pin_flag = false;

static NSString * s_str_accounthash = nil;
static NSString * s_str_website = nil;
static NSString * s_str_last_error=nil;

static int s_license_ok = -1;  // -1 , 0, 1  -1:license 不成功  1:license 测试license 0:正式license

#define MAX_BUFFER_LEN 1024


static NSMutableArray * s_array_cert_table = nil;

unsigned int itrus_global_check_cert = 0;

#define CHAR_TO_16(achar) ((achar)>='0'&&(achar)<='9'?((achar)-'0'):((achar)-'A' + 10))

//#ifdef NSS_ENABLE_ECC
//typedef struct curveNameTagPairStr {
//    char *curveName;
//    SECOidTag curveOidTag;
//} CurveNameTagPair;
//
//#define DEFAULT_CURVE_OID_TAG  SEC_OID_SECG_EC_SECP192R1
///* #define DEFAULT_CURVE_OID_TAG  SEC_OID_SECG_EC_SECP160R1 */
//
//static CurveNameTagPair nameTagPair[] =
//{
//    { "sect163k1", SEC_OID_SECG_EC_SECT163K1},
//    { "nistk163", SEC_OID_SECG_EC_SECT163K1},
//    { "sect163r1", SEC_OID_SECG_EC_SECT163R1},
//    { "sect163r2", SEC_OID_SECG_EC_SECT163R2},
//    { "nistb163", SEC_OID_SECG_EC_SECT163R2},
//    { "sect193r1", SEC_OID_SECG_EC_SECT193R1},
//    { "sect193r2", SEC_OID_SECG_EC_SECT193R2},
//    { "sect233k1", SEC_OID_SECG_EC_SECT233K1},
//    { "nistk233", SEC_OID_SECG_EC_SECT233K1},
//    { "sect233r1", SEC_OID_SECG_EC_SECT233R1},
//    { "nistb233", SEC_OID_SECG_EC_SECT233R1},
//    { "sect239k1", SEC_OID_SECG_EC_SECT239K1},
//    { "sect283k1", SEC_OID_SECG_EC_SECT283K1},
//    { "nistk283", SEC_OID_SECG_EC_SECT283K1},
//    { "sect283r1", SEC_OID_SECG_EC_SECT283R1},
//    { "nistb283", SEC_OID_SECG_EC_SECT283R1},
//    { "sect409k1", SEC_OID_SECG_EC_SECT409K1},
//    { "nistk409", SEC_OID_SECG_EC_SECT409K1},
//    { "sect409r1", SEC_OID_SECG_EC_SECT409R1},
//    { "nistb409", SEC_OID_SECG_EC_SECT409R1},
//    { "sect571k1", SEC_OID_SECG_EC_SECT571K1},
//    { "nistk571", SEC_OID_SECG_EC_SECT571K1},
//    { "sect571r1", SEC_OID_SECG_EC_SECT571R1},
//    { "nistb571", SEC_OID_SECG_EC_SECT571R1},
//    { "secp160k1", SEC_OID_SECG_EC_SECP160K1},
//    { "secp160r1", SEC_OID_SECG_EC_SECP160R1},
//    { "secp160r2", SEC_OID_SECG_EC_SECP160R2},
//    { "secp192k1", SEC_OID_SECG_EC_SECP192K1},
//    { "secp192r1", SEC_OID_SECG_EC_SECP192R1},
//    { "nistp192", SEC_OID_SECG_EC_SECP192R1},
//    { "secp224k1", SEC_OID_SECG_EC_SECP224K1},
//    { "secp224r1", SEC_OID_SECG_EC_SECP224R1},
//    { "nistp224", SEC_OID_SECG_EC_SECP224R1},
//    { "secp256k1", SEC_OID_SECG_EC_SECP256K1},
//    { "secp256r1", SEC_OID_SECG_EC_SECP256R1},
//    { "nistp256", SEC_OID_SECG_EC_SECP256R1},
//    { "secp384r1", SEC_OID_SECG_EC_SECP384R1},
//    { "nistp384", SEC_OID_SECG_EC_SECP384R1},
//    { "secp521r1", SEC_OID_SECG_EC_SECP521R1},
//    { "nistp521", SEC_OID_SECG_EC_SECP521R1},
//
//    { "prime192v1", SEC_OID_ANSIX962_EC_PRIME192V1 },
//    { "prime192v2", SEC_OID_ANSIX962_EC_PRIME192V2 },
//    { "prime192v3", SEC_OID_ANSIX962_EC_PRIME192V3 },
//    { "prime239v1", SEC_OID_ANSIX962_EC_PRIME239V1 },
//    { "prime239v2", SEC_OID_ANSIX962_EC_PRIME239V2 },
//    { "prime239v3", SEC_OID_ANSIX962_EC_PRIME239V3 },
//
//    { "c2pnb163v1", SEC_OID_ANSIX962_EC_C2PNB163V1 },
//    { "c2pnb163v2", SEC_OID_ANSIX962_EC_C2PNB163V2 },
//    { "c2pnb163v3", SEC_OID_ANSIX962_EC_C2PNB163V3 },
//    { "c2pnb176v1", SEC_OID_ANSIX962_EC_C2PNB176V1 },
//    { "c2tnb191v1", SEC_OID_ANSIX962_EC_C2TNB191V1 },
//    { "c2tnb191v2", SEC_OID_ANSIX962_EC_C2TNB191V2 },
//    { "c2tnb191v3", SEC_OID_ANSIX962_EC_C2TNB191V3 },
//    { "c2onb191v4", SEC_OID_ANSIX962_EC_C2ONB191V4 },
//    { "c2onb191v5", SEC_OID_ANSIX962_EC_C2ONB191V5 },
//    { "c2pnb208w1", SEC_OID_ANSIX962_EC_C2PNB208W1 },
//    { "c2tnb239v1", SEC_OID_ANSIX962_EC_C2TNB239V1 },
//    { "c2tnb239v2", SEC_OID_ANSIX962_EC_C2TNB239V2 },
//    { "c2tnb239v3", SEC_OID_ANSIX962_EC_C2TNB239V3 },
//    { "c2onb239v4", SEC_OID_ANSIX962_EC_C2ONB239V4 },
//    { "c2onb239v5", SEC_OID_ANSIX962_EC_C2ONB239V5 },
//    { "c2pnb272w1", SEC_OID_ANSIX962_EC_C2PNB272W1 },
//    { "c2pnb304w1", SEC_OID_ANSIX962_EC_C2PNB304W1 },
//    { "c2tnb359v1", SEC_OID_ANSIX962_EC_C2TNB359V1 },
//    { "c2pnb368w1", SEC_OID_ANSIX962_EC_C2PNB368W1 },
//    { "c2tnb431r1", SEC_OID_ANSIX962_EC_C2TNB431R1 },
//
//    { "secp112r1", SEC_OID_SECG_EC_SECP112R1},
//    { "secp112r2", SEC_OID_SECG_EC_SECP112R2},
//    { "secp128r1", SEC_OID_SECG_EC_SECP128R1},
//    { "secp128r2", SEC_OID_SECG_EC_SECP128R2},
//
//    { "sect113r1", SEC_OID_SECG_EC_SECT113R1},
//    { "sect113r2", SEC_OID_SECG_EC_SECT113R2},
//    { "sect131r1", SEC_OID_SECG_EC_SECT131R1},
//    { "sect131r2", SEC_OID_SECG_EC_SECT131R2},
//
//    { "nistp256SM2", SEC_OID_EC_NIST_P256_SM2},
//};
//
//static SECKEYECParams *getECParams(const char *curve)
//{
//    SECKEYECParams *ecparams;
//    SECOidData *oidData = NULL;
//    SECOidTag curveOidTag = SEC_OID_UNKNOWN; /* default */
//    int i, numCurves;
//
//    if (curve != NULL) {
//        numCurves = sizeof(nameTagPair)/sizeof(CurveNameTagPair);
//        for (i = 0; ((i < numCurves) && (curveOidTag == SEC_OID_UNKNOWN));
//             i++) {
//            if (PL_strcmp(curve, nameTagPair[i].curveName) == 0)
//                curveOidTag = nameTagPair[i].curveOidTag;
//        }
//    }
//
//    /* Return NULL if curve name is not recognized */
//    if ((curveOidTag == SEC_OID_UNKNOWN) ||
//        (oidData = SECOID_FindOIDByTag(curveOidTag)) == NULL) {
//        fprintf(stderr, "Unrecognized elliptic curve %s\n", curve);
//        return NULL;
//    }
//
//    ecparams = SECITEM_AllocItem(NULL, NULL, (2 + oidData->oid.len));
//
//    /*
//     * ecparams->data needs to contain the ASN encoding of an object ID (OID)
//     * representing the named curve. The actual OID is in
//     * oidData->oid.data so we simply prepend 0x06 and OID length
//     */
//    ecparams->data[0] = SEC_ASN1_OBJECT_ID;
//    ecparams->data[1] = oidData->oid.len;
//    memcpy(ecparams->data + 2, oidData->oid.data, oidData->oid.len);
//
//    return ecparams;
//}
//#endif /* NSS_ENABLE_ECC */

#include "ecc_sm2.h"


@interface CertInfoClass : NSObject
{
    NSString * m_id;
    NSString * m_emial;
    certInfo * m_info;
    NSString * m_nick_name;
    PRTime m_notBefore;
    PRTime m_notAfter;
}

@property(atomic, strong) NSString * m_id;
@property(atomic, strong) NSString * m_emial;
@property(atomic, strong) certInfo * m_info;
@property(atomic, strong) NSString * m_nick_name;
@property(assign) PRTime m_notBefore;
@property(assign) PRTime m_notAfter;

@end


@implementation CertInfoClass

@synthesize m_id;
@synthesize m_emial;
@synthesize m_info;
@synthesize m_nick_name;
@synthesize m_notBefore;
@synthesize m_notAfter;

@end



int initWebsiteAndAccountHash(IN const NSString * str_website,IN const NSString * str_accounthash)
{
    if (str_website) {
        s_str_website = [[NSString alloc] initWithString:(NSString * )str_website];
    }
    
    if (str_accounthash) {
        s_str_accounthash = [[NSString alloc] initWithString:(NSString * )str_accounthash];
    }
    
    return EStateSuccess;
}

int getLastErrInfo(OUT NSString * * str_last_error)
{
    if (s_str_last_error) {
        * str_last_error = [[NSString alloc] initWithString:s_str_last_error];
    }
    
    return EStateSuccess;
}

int setLastErrInfo(IN int err_code)
{
    switch (err_code) {
        case EStateSuccess:
            break;
        case  EStateErrorInitDB:
            s_str_last_error = @"初始化数据库失败";
            break;
        case  EStateErrorInitPIN:
            s_str_last_error = @"初始化pin出错";
            break;
        case  EStateErrorUninitPIN:
            s_str_last_error = @"未初始化pin";
            break;
        case  EStateErrorMemLittle:
            s_str_last_error = @"内存不足";
            break;
        case  EStateErrorNoSlot:
            s_str_last_error = @"没有key";
            break;
        case  EStateErrorInvalidArg:
            s_str_last_error = @"非法参数";
            break;
        case  EStateErrorPIN:
            s_str_last_error = @"pin码错误";
            break;
        case EStateErrorCert:
            s_str_last_error = @"证书错误";
            break;
        case EStateErrorNeedLogin:
            s_str_last_error = @"需要登录";
            break;
        case  EStateErrorGenPriKey:
            s_str_last_error = @"生成私钥出错";
            break;
        case EStateErrorSignData:
            s_str_last_error = @"签名数据出错";
            break;
        case EStateErrorVerifySign:
            s_str_last_error = @"验证出错";
            break;
        case  EStateErrorGenPubInfo:
            s_str_last_error = @"生成公钥信息出错";
            break;
        case   EStateErrorGenCertReq:
            s_str_last_error = @"生成证书请求出错";
            break;
        case EStateErrorCertNotExist:
            s_str_last_error = @"证书不存在";
            break;
        case  EStateErrorNoCert:
            s_str_last_error = @"没有证书";
            break;
        case EStateErrorNoPriKey:
            s_str_last_error = @"没有私钥";
            break;
        case  EStateErrorNoPubKey:
            s_str_last_error = @"没有公钥";
            break;
        case EStateErrorEncrypt:
            s_str_last_error = @"加密出错";
            break;
        case   EStateErrorDecrypt:
            s_str_last_error = @"解密出错";
            break;
        case EStateErrorHashData:
            s_str_last_error = @"哈希出错";
            break;
        case   EStateErrorImportCert:
            s_str_last_error = @"导入证书出错";
            break;
        case EStateErrorKeyUsage:
            s_str_last_error = @"KEY用途不正确";
            break;
        case  EStateErrorCreateSignedData:
            s_str_last_error = @"创建签名数据出错";
            break;
        case EStateErrorIncludeCertChain:
            s_str_last_error = @"包含证书链出错";
            break;
        case  EStateErrorEncodeItem:
            s_str_last_error = @"p7编码出错";
            break;
        case EStateErrorDecodeItem:
            s_str_last_error = @"p7解码出错";
            break;
        case EStateErrorVerifyDetachedSignature:
            s_str_last_error = @"p7Detach验签出错";
            break;
        case EStateErrorVerifySignature:
            s_str_last_error = @"p7Attach验签出错";
            break;
        case  EStateErrorSetContent:
            s_str_last_error = @"p7设置原文出错";
            break;
        case EStateErrorAddCertificate:
            s_str_last_error = @"添加证书出错";
            break;
        case EStateErrorNetwork:
            s_str_last_error = @"网络出错";
            break;
        case EStateFailure:
            s_str_last_error = @"操作失败";
            break;
            
        case EStateErrorLicenseNotExist: // LICENSE不存在
            s_str_last_error = @"LICENSE不存在";
            break;
            
        case EStateErrorLicenseVerify: //
            s_str_last_error = @"LICENSE验证不通过";

            break;
        default:
            break;
    }
    
    return EStateSuccess;
}


int enrollCertOld(OUT NSString * * str_certificate, IN const userInfo * ptr_user_info, IN const NSString * str_aaPassPort,IN const NSString * str_certReqChallenge, IN int i_auto_approval_certificate)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    int iRet  = 0;
    
    NSString * strReqBase64;
    iRet = genCSR(&strReqBase64, @"", ptr_user_info.userName, ptr_user_info.userEmail, nil, nil, 2048, @"rsa");
    
    if (iRet) {
        setLastErrInfo(EStateErrorGenCertReq);
        return EStateErrorGenCertReq;
    }
    
    UserAPIServiceSvc_userInfo * tmpUseInfo = [[UserAPIServiceSvc_userInfo  alloc] init];
    
    
    tmpUseInfo.accountId =  ptr_user_info.accountId;
    tmpUseInfo.userName =  ptr_user_info.userName;
    tmpUseInfo.userSurname =  ptr_user_info.userSurname;
    tmpUseInfo.userEmail =  ptr_user_info.userEmail;
    tmpUseInfo.userOrganization =  ptr_user_info.userOrganization;
    tmpUseInfo.userOrgunit =  ptr_user_info.userOrgunit;
    tmpUseInfo.userCountry =  ptr_user_info.userCountry;
    tmpUseInfo.userState =  ptr_user_info.userState;
    tmpUseInfo.userLocality =  ptr_user_info.userLocality;
    tmpUseInfo.userStreet =  ptr_user_info.userStreet;
    tmpUseInfo.userDns =  ptr_user_info.userDns;
    tmpUseInfo.userIp =  ptr_user_info.userIp;
    tmpUseInfo.userTitle =  ptr_user_info.userTitle;
    tmpUseInfo.userDescription =  ptr_user_info.userDescription;
    tmpUseInfo.userAdditionalField1 =  ptr_user_info.userAdditionalField1;
    tmpUseInfo.userAdditionalField2 =  ptr_user_info.userAdditionalField2;
    tmpUseInfo.userAdditionalField3 =  ptr_user_info.userAdditionalField3;
    tmpUseInfo.userAdditionalField4 =  ptr_user_info.userAdditionalField4;
    tmpUseInfo.userAdditionalField5 =  ptr_user_info.userAdditionalField5;
    tmpUseInfo.userAdditionalField5 =  ptr_user_info.userAdditionalField6;
    tmpUseInfo.userAdditionalField7 =  ptr_user_info.userAdditionalField7;
    tmpUseInfo.userAdditionalField8 =  ptr_user_info.userAdditionalField8;
    tmpUseInfo.userAdditionalField9 =  ptr_user_info.userAdditionalField9;
    tmpUseInfo.userAdditionalField10 =  ptr_user_info.userAdditionalField10;
    
    if (EAutoApprovalCertificate == i_auto_approval_certificate)
    {
        if (nil == str_certificate) {
            setLastErrInfo(EStateErrorInvalidArg);
            return EStateErrorInvalidArg;
        }
        
        UserAPIServiceSoapBinding *binding = nil;
        
        if (s_str_website) {
            binding = [[UserAPIServiceSoapBinding alloc] initWithAddress:s_str_website];
        }
        else
        {
            binding = [UserAPIServiceSvc UserAPIServiceSoapBinding];
        }
        
        UserAPIServiceSvc_enrollCertAA * request = [[UserAPIServiceSvc_enrollCertAA alloc]init];
        
        //    /* elements */
        //    @synthesize userInfo;
        //    @synthesize certReqBuf;
        //    @synthesize accountHash;
        //    @synthesize aaCheckPoint;
        //    @synthesize passCode;
        //    @synthesize json;
        //    /* attributes */
        
        request.userInfo = tmpUseInfo;
        
        request.certReqBuf = strReqBase64;
        
        request.aaCheckPoint = (NSString *)str_aaPassPort;
        request.accountHash = (NSString *)s_str_accounthash;
        UserAPIServiceSoapBindingResponse * response = [binding enrollCertAAUsingParameters:request];
        
        NSArray *bodyParts = response.bodyParts;
        NSError *error = response.error;
        
        if (nil == error) {
            for(id bodyPart in bodyParts)
            {
                if([bodyPart isKindOfClass:[UserAPIServiceSvc_enrollCertAAResponse class]])
                {
                    UserAPIServiceSvc_certInfo * info =  ((UserAPIServiceSvc_enrollCertAAResponse * )bodyPart).return_;
                    * str_certificate = info.certSignBuf;
                    return EStateSuccess;
                }
                if ([bodyPart isKindOfClass:[SOAPFault class]]) {
                    
                    s_str_last_error = [[NSString alloc] initWithString:[(SOAPFault *)bodyPart faultstring]];
                    
                    return EStateFailure;
                }
            }
            return EStateFailure;
        }
        else
        {
            setLastErrInfo(EStateErrorNetwork);
            return EStateFailure;
        }
    }
    else
    {
        UserAPIServiceSoapBinding *binding = nil;
        
        if (s_str_website) {
            binding = [[UserAPIServiceSoapBinding alloc] initWithAddress:s_str_website];
        }
        else
        {
            binding = [UserAPIServiceSvc UserAPIServiceSoapBinding];
        }
        
        UserAPIServiceSvc_enrollCert * request = [[UserAPIServiceSvc_enrollCert alloc]init];
        
        
        //    /* elements */
        //    @synthesize userInfo;
        //    @synthesize certReqBuf;
        //    @synthesize certReqChallenge;
        //    @synthesize accountHash;
        //    @synthesize json;
        //    /* attributes */
        
        request.userInfo = tmpUseInfo;
        
        request.certReqBuf = strReqBase64;
        
        request.certReqChallenge = (NSString *)str_certReqChallenge;
        request.accountHash = (NSString *)s_str_accounthash;
        //    request.json = @"{certKmcReq2:'kmcClientVersion=20101201',cryptProv:'1'}";
        
        UserAPIServiceSoapBindingResponse * response = [binding enrollCertUsingParameters:request];
        
        NSArray *bodyParts = response.bodyParts;
        NSError *error = response.error;
        
        if (nil == error) {
            for(id bodyPart in bodyParts)
            {
                if([bodyPart isKindOfClass:[UserAPIServiceSvc_enrollCertResponse class]])
                {
                    return EStateSuccess;
                }
                if ([bodyPart isKindOfClass:[SOAPFault class]]) {
                    
                    s_str_last_error = [[NSString alloc] initWithString:[(SOAPFault *)bodyPart faultstring]];
                    
                    return EStateFailure;
                }
            }
            return EStateFailure;
        }
        else
        {
            setLastErrInfo(EStateErrorNetwork);
            return EStateFailure;
        }
    }
    
    return EStateSuccess;
}


int enrollCert(OUT NSString * * str_certificate, IN const NSString * str_CSR,IN const userInfo * ptr_user_info, IN const NSString * str_aaPassPort,IN const NSString * str_certReqChallenge, IN int i_auto_approval_certificate)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    NSString * strReqBase64 = (NSString * )str_CSR;
    
    UserAPIServiceSvc_userInfo * tmpUseInfo = [[UserAPIServiceSvc_userInfo  alloc] init];
    
    
    tmpUseInfo.accountId =  ptr_user_info.accountId;
    tmpUseInfo.userName =  ptr_user_info.userName;
    tmpUseInfo.userSurname =  ptr_user_info.userSurname;
    tmpUseInfo.userEmail =  ptr_user_info.userEmail;
    tmpUseInfo.userOrganization =  ptr_user_info.userOrganization;
    tmpUseInfo.userOrgunit =  ptr_user_info.userOrgunit;
    tmpUseInfo.userCountry =  ptr_user_info.userCountry;
    tmpUseInfo.userState =  ptr_user_info.userState;
    tmpUseInfo.userLocality =  ptr_user_info.userLocality;
    tmpUseInfo.userStreet =  ptr_user_info.userStreet;
    tmpUseInfo.userDns =  ptr_user_info.userDns;
    tmpUseInfo.userIp =  ptr_user_info.userIp;
    tmpUseInfo.userTitle =  ptr_user_info.userTitle;
    tmpUseInfo.userDescription =  ptr_user_info.userDescription;
    tmpUseInfo.userAdditionalField1 =  ptr_user_info.userAdditionalField1;
    tmpUseInfo.userAdditionalField2 =  ptr_user_info.userAdditionalField2;
    tmpUseInfo.userAdditionalField3 =  ptr_user_info.userAdditionalField3;
    tmpUseInfo.userAdditionalField4 =  ptr_user_info.userAdditionalField4;
    tmpUseInfo.userAdditionalField5 =  ptr_user_info.userAdditionalField5;
    tmpUseInfo.userAdditionalField5 =  ptr_user_info.userAdditionalField6;
    tmpUseInfo.userAdditionalField7 =  ptr_user_info.userAdditionalField7;
    tmpUseInfo.userAdditionalField8 =  ptr_user_info.userAdditionalField8;
    tmpUseInfo.userAdditionalField9 =  ptr_user_info.userAdditionalField9;
    tmpUseInfo.userAdditionalField10 =  ptr_user_info.userAdditionalField10;
    
    if (EAutoApprovalCertificate == i_auto_approval_certificate)
    {
        if (nil == str_certificate) {
            setLastErrInfo(EStateErrorInvalidArg);
            return EStateErrorInvalidArg;
        }
        
        UserAPIServiceSoapBinding *binding = nil;
        
        if (s_str_website) {
            binding = [[UserAPIServiceSoapBinding alloc] initWithAddress:s_str_website];
        }
        else
        {
            binding = [UserAPIServiceSvc UserAPIServiceSoapBinding];
        }
        
        UserAPIServiceSvc_enrollCertAA * request = [[UserAPIServiceSvc_enrollCertAA alloc]init];
        
        //    /* elements */
        //    @synthesize userInfo;
        //    @synthesize certReqBuf;
        //    @synthesize accountHash;
        //    @synthesize aaCheckPoint;
        //    @synthesize passCode;
        //    @synthesize json;
        //    /* attributes */
        
        request.userInfo = tmpUseInfo;
        
        request.certReqBuf = strReqBase64;
        
        request.aaCheckPoint = (NSString *)str_aaPassPort;
        request.accountHash = (NSString *)s_str_accounthash;
        UserAPIServiceSoapBindingResponse * response = [binding enrollCertAAUsingParameters:request];
        
        NSArray *bodyParts = response.bodyParts;
        NSError *error = response.error;
        
        if (nil == error) {
            for(id bodyPart in bodyParts)
            {
                if([bodyPart isKindOfClass:[UserAPIServiceSvc_enrollCertAAResponse class]])
                {
                    UserAPIServiceSvc_certInfo * info =  ((UserAPIServiceSvc_enrollCertAAResponse * )bodyPart).return_;
                    * str_certificate = info.certSignBuf;
                    return EStateSuccess;
                }
                if ([bodyPart isKindOfClass:[SOAPFault class]]) {
                    
                    s_str_last_error = [[NSString alloc] initWithString:[(SOAPFault *)bodyPart faultstring]];
                    
                    return EStateFailure;
                }
            }
            return EStateFailure;
        }
        else
        {
            setLastErrInfo(EStateErrorNetwork);
            return EStateFailure;
        }
    }
    else
    {
        UserAPIServiceSoapBinding *binding = nil;
        
        if (s_str_website) {
            binding = [[UserAPIServiceSoapBinding alloc] initWithAddress:s_str_website];
        }
        else
        {
            binding = [UserAPIServiceSvc UserAPIServiceSoapBinding];
        }
        
        UserAPIServiceSvc_enrollCert * request = [[UserAPIServiceSvc_enrollCert alloc]init];
        
        
        //    /* elements */
        //    @synthesize userInfo;
        //    @synthesize certReqBuf;
        //    @synthesize certReqChallenge;
        //    @synthesize accountHash;
        //    @synthesize json;
        //    /* attributes */
        
        request.userInfo = tmpUseInfo;
        
        request.certReqBuf = strReqBase64;
        
        request.certReqChallenge = (NSString *)str_certReqChallenge;
        request.accountHash = (NSString *)s_str_accounthash;
        //    request.json = @"{certKmcReq2:'kmcClientVersion=20101201',cryptProv:'1'}";
        
        UserAPIServiceSoapBindingResponse * response = [binding enrollCertUsingParameters:request];
        
        NSArray *bodyParts = response.bodyParts;
        NSError *error = response.error;
        
        if (nil == error) {
            for(id bodyPart in bodyParts)
            {
                if([bodyPart isKindOfClass:[UserAPIServiceSvc_enrollCertResponse class]])
                {
                    return EStateSuccess;
                }
                if ([bodyPart isKindOfClass:[SOAPFault class]]) {
                    
                    s_str_last_error = [[NSString alloc] initWithString:[(SOAPFault *)bodyPart faultstring]];
                    
                    return EStateFailure;
                }
            }
            return EStateFailure;
        }
        else
        {
            setLastErrInfo(EStateErrorNetwork);
            return EStateFailure;
        }
    }
    
    return EStateSuccess;
}


int pickupCert(OUT NSString * * str_certificate, IN const NSString * str_certPin, IN const NSString * str_certReqChallenge)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    UserAPIServiceSoapBinding *binding = nil;
    
    if (s_str_website) {
        binding = [[UserAPIServiceSoapBinding alloc] initWithAddress:s_str_website];
    }
    else
    {
        binding = [UserAPIServiceSvc UserAPIServiceSoapBinding];
    }
    
    UserAPIServiceSvc_pickupCert * request = [[UserAPIServiceSvc_pickupCert alloc]init];
    
    request.certPin = (NSString *)str_certPin;
    request.certReqChallenge = (NSString *)str_certReqChallenge;
    request.accountHash = (NSString *)s_str_accounthash;
    
    //    /* elements */
    //    @synthesize certPin;
    //    @synthesize certReqChallenge;
    //    @synthesize certReqBuf;
    //    @synthesize accountHash;
    //    @synthesize json;
    //    /* attributes */
    
    UserAPIServiceSoapBindingResponse * response = [binding pickupCertUsingParameters:request];
    
    NSArray *bodyParts = response.bodyParts;
    NSError *error = response.error;
    
    if (nil == error) {
        for(id bodyPart in bodyParts)
        {
            if([bodyPart isKindOfClass:[UserAPIServiceSvc_pickupCertResponse class]])
            {
                UserAPIServiceSvc_certInfo * info =  ((UserAPIServiceSvc_pickupCertResponse * )bodyPart).return_;
                * str_certificate = info.certSignBuf;
                return EStateSuccess;
            }
            if ([bodyPart isKindOfClass:[SOAPFault class]]) {
                
                s_str_last_error = [[NSString alloc] initWithString:[(SOAPFault *)bodyPart faultstring]];
                
                return EStateFailure;
            }
        }
        return EStateFailure;
    }
    else
    {
        setLastErrInfo(EStateErrorNetwork);
        return EStateFailure;
    }
    
    
    return EStateSuccess;
}



int renewCert(OUT NSString * * str_certificate, IN const renewInfo * ptr_renew_info)
{
#if UserAPIService_AA_MODEL
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    UserAPIServiceSoapBinding *binding = nil;
    
    if (s_str_website) {
        binding = [[UserAPIServiceSoapBinding alloc] initWithAddress:s_str_website];
    }
    else
    {
        binding = [UserAPIServiceSvc UserAPIServiceSoapBinding];
    }
    
    UserAPIServiceSvc_renewCertAA * request = [[UserAPIServiceSvc_renewCertAA alloc]init];
    
    
    UserAPIServiceSvc_certInfo * certInfo = [[UserAPIServiceSvc_certInfo alloc] init];
    
    certInfo.certSignBuf = ptr_renew_info.origCert;
    certInfo.certSerialNumber = ptr_renew_info.origCertSerialNumber;
    certInfo.certReqBufType = ptr_renew_info.certReqBufType;
    certInfo.certReqBuf = ptr_renew_info.certReqBuf;
    certInfo.certReqChallenge = ptr_renew_info.certReqChallengeOld;
    
    
    
    //    UserAPIServiceSvc_userInfo * userinfo = [[UserAPIServiceSvc_userInfo alloc] init];
    //
    //    userinfo.
    //
    
    //    /* elements */
    //    @synthesize userInfo;
    //    @synthesize origin;
    //    @synthesize accountHash;
    //    @synthesize aaCheckPoint;
    //    @synthesize passCode;
    //    @synthesize json;
    //    /* attributes */
    
    
    request.accountHash = (NSString *)s_str_accounthash;
    request.passCode = ptr_renew_info.certReqChallenge;
    request.origin = certInfo;
    request.aaCheckPoint = ptr_renew_info.passcode;
    request.json = [[NSString alloc] initWithFormat:@"{PKCSINFORMATION:'%@',CERT_REQ_BUF:'%@'}",ptr_renew_info.pkcsInformation,ptr_renew_info.certReqBuf];
    
    
    UserAPIServiceSoapBindingResponse * response = [binding renewCertAAUsingParameters:request];
    
#else
    //    /* elements */
    //    @synthesize userInfo;
    //    @synthesize origin;
    //    @synthesize accountHash;
    //    @synthesize json;
    //    /* attributes */
    
#endif
    
    
    NSArray *bodyParts = response.bodyParts;
    NSError *error = response.error;
    
    if (nil == error) {
        for(id bodyPart in bodyParts)
        {
            if([bodyPart isKindOfClass:[UserAPIServiceSvc_renewCertAAResponse class]])
            {
                UserAPIServiceSvc_certInfo * info =  ((UserAPIServiceSvc_renewCertAAResponse * )bodyPart).return_;
                * str_certificate = info.certSignBuf;
                return EStateSuccess;
            }
            if ([bodyPart isKindOfClass:[SOAPFault class]]) {
                
                s_str_last_error = [[NSString alloc] initWithString:[(SOAPFault *)bodyPart faultstring]];
                
                return EStateFailure;
            }
        }
        return EStateFailure;
    }
    else
    {
        setLastErrInfo(EStateErrorNetwork);
        return EStateFailure;
    }
    
    return EStateSuccess;
}


int revokeCert(IN const NSString * str_cert_serial_number, IN const NSString * str_revocation_reason_code,IN const NSString * str_pri_pwd)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    
    if (false == s_user_pin_flag)
    {
        setLastErrInfo(EStateErrorNeedLogin);
        return EStateErrorNeedLogin;
    }
    
    UserAPIServiceSoapBinding *binding = nil;
    
    if (s_str_website) {
        binding = [[UserAPIServiceSoapBinding alloc] initWithAddress:s_str_website];
    }
    else
    {
        binding = [UserAPIServiceSvc UserAPIServiceSoapBinding];
    }
    
    UserAPIServiceSvc_revokeCert * request = [[UserAPIServiceSvc_revokeCert alloc]init];
    
    //    /* elements */
    //    @synthesize serialNumber;
    //    @synthesize certReqChallenge;
    //    @synthesize certRevokeReason;
    //    @synthesize accountHash;
    //    @synthesize json;
    //    /* attributes */
    
    request.serialNumber = (NSString *)str_cert_serial_number;
    request.certRevokeReason = (NSString *)str_revocation_reason_code;
    request.certReqChallenge = (NSString *)str_pri_pwd;
    request.accountHash = (NSString *)s_str_accounthash;
    
    
    UserAPIServiceSoapBindingResponse * response = [binding revokeCertUsingParameters:request];
    
    NSArray *bodyParts = response.bodyParts;
    NSError *error = response.error;
    
    if (nil == error) {
        for(id bodyPart in bodyParts)
        {
            if([bodyPart isKindOfClass:[UserAPIServiceSvc_revokeCertResponse class]])
            {
                return deleteCertBySerialNumber(str_cert_serial_number);
            }
            if ([bodyPart isKindOfClass:[SOAPFault class]]) {
                
                s_str_last_error = [[NSString alloc] initWithString:[(SOAPFault *)bodyPart faultstring]];
                
                return EStateFailure;
            }
        }
    }
    else
    {
        setLastErrInfo(EStateErrorNetwork);
        return EStateFailure;
    }
    
    return EStateSuccess;
}


int getEnrollStatus(OUT NSString * * str_status, IN const NSString * str_name, IN const NSString * str_emial,IN const NSString * str_time_start, IN const NSString * str_time_stop)
{
    setLastErrInfo(EStateFailure);
    return EStateFailure;
}



int filterCert(OUT NSMutableArray * * str_cert_id , IN const NSString * str_issuer_theme, IN const NSString * str_cert_serial_number,IN const NSString * str_cert_theme, IN int i_cert_status, IN int i_cert_update_remain_days)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    
    if (nil == str_cert_id) {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    
    CERTCertListNode *node;
    
    SECStatus rv = 0;
    
    s_array_cert_table = [[NSMutableArray alloc] init];
    
    * str_cert_id = [[NSMutableArray alloc] init];
    
    /*初始化数据库*/
    rv = NSS_Initialize(GetSystemDBDir(),
                        "", "",
                        "secmod.db", 0);
    
    if (SECSuccess != rv) {
        setLastErrInfo(EStateErrorInitDB);
        return EStateErrorInitDB;
    }
    
    PK11SlotInfo * slot = PK11_GetInternalKeySlot();
    
    if (NULL == slot) {
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoSlot);
        return EStateErrorNoSlot;
    }
    
    CERTCertList * certs = PK11_ListCertsInSlot(slot);
    
    if (NULL == slot) {
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoCert);
        return EStateErrorNoCert;
    }
    
    
    
	if (certs) {
        int i = 0;
	    for (node = CERT_LIST_HEAD(certs); !CERT_LIST_END(node,certs);
             node = CERT_LIST_NEXT(node)) {
            CERTCertificate* cert;
            
            cert = node->cert;
            
            bool isadd = false;
            
            CertInfoClass * item = [[CertInfoClass alloc] init];
            
            item.m_id = [[NSString alloc] initWithFormat:@"%d", i];
            
            if (cert->emailAddr) {
                item.m_emial = [[NSString alloc] initWithCString:cert->emailAddr encoding:NSUTF8StringEncoding];
            }
            
            item.m_info = [[certInfo alloc] init];
            
            if (cert->subjectName) {
                NSString * cnName = [[NSString alloc] initWithCString:cert->subjectName encoding:NSUTF8StringEncoding];
                
                NSRange foundLeft = [cnName rangeOfString:@"CN=" options:NSCaseInsensitiveSearch];
                
                cnName = [cnName substringFromIndex:foundLeft.location + foundLeft.length];//开始截取
                
                NSRange foundRight = [cnName rangeOfString:@"," options:NSCaseInsensitiveSearch];
                
                if (foundRight.length) {
                    cnName = [cnName substringToIndex:0 + foundRight.location];//开始截取
                }
                
                item.m_info.CommonName = cnName;
                
                item.m_info.Subject = [[NSString alloc] initWithCString:cert->subjectName encoding:NSUTF8StringEncoding];
                
            }
            
            if (cert->issuerName) {
                item.m_info.Issuer = [[NSString alloc] initWithCString:cert->issuerName encoding:NSUTF8StringEncoding];
            }
            item.m_info.CSP = nil;
            item.m_info.KeyContainer = nil;
            
            char serial_number[256] = {0};
            
            for (int k = 0; k < cert->serialNumber.len; k++) {
                sprintf(serial_number + 2 * k, "%02X", cert->serialNumber.data[k]);
            }
            
            
            item.m_info.SerialNumber = [[NSString alloc] initWithCString:serial_number encoding:NSUTF8StringEncoding];
            
            item.m_info.KeyUsage = [[NSString alloc] initWithFormat:@"%d", cert->keyUsage];
            item.m_info.GetEncodedCert = ECertDer;
            
            item.m_info.PublicKey = [GTMBase64 stringByEncodingBytes:cert->derPublicKey.data length:cert->derPublicKey.len];
            
            if (cert->nickname)
            {
                item.m_nick_name = [[NSString alloc] initWithCString:cert->nickname encoding:NSUTF8StringEncoding];
            }
            
            PRTime notBefore;
            PRTime notAfter;
            
            CERT_GetCertTimes(cert, &notBefore, &notAfter);
            
            item.m_notAfter = notAfter;
            item.m_notBefore = notBefore;
            
            item.m_info.ValidFrom = nil;
            item.m_info.ValidTo = nil;
            
            
            NSDate *_datelineAfter = [NSDate dateWithTimeIntervalSince1970:notAfter/1000000];
            NSDate *_datelineBefore = [NSDate dateWithTimeIntervalSince1970:notBefore/1000000];
            
            NSDateFormatter *dateformat=[[NSDateFormatter alloc] init];
            [dateformat setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
            
            item.m_info.ValidTo = [dateformat stringFromDate:_datelineAfter];
            item.m_info.ValidFrom = [dateformat stringFromDate:_datelineBefore];
            
            
            if (nil == str_issuer_theme || NSOrderedSame == [str_issuer_theme compare:@"" options:NSCaseInsensitiveSearch])
            {
                if (nil == str_cert_serial_number || NSOrderedSame == [str_cert_serial_number compare:@"" options:NSCaseInsensitiveSearch])
                {
                    if (nil == str_cert_theme || NSOrderedSame == [str_cert_theme compare:@"" options:NSCaseInsensitiveSearch])
                    {
                        isadd = true;
                    }
                    else
                    {
                        if(NSOrderedSame != [str_cert_theme compare:item.m_info.Subject options:NSCaseInsensitiveSearch])
                        {
                            continue;
                        }
                        isadd = true;
                    }
                }
                else
                {
                    if(NSOrderedSame != [str_cert_serial_number compare:item.m_info.SerialNumber options:NSCaseInsensitiveSearch])
                    {
                        continue;
                    }
                    
                    if (nil == str_cert_theme || NSOrderedSame == [str_cert_theme compare:@"" options:NSCaseInsensitiveSearch])
                    {
                        isadd = true;
                    }
                    else
                    {
                        if(NSOrderedSame != [str_cert_theme compare:item.m_info.Subject options:NSCaseInsensitiveSearch])
                        {
                            continue;
                        }
                        isadd = true;
                    }
                }
            }
            else
            {
                if(NSOrderedSame != [str_issuer_theme compare:item.m_info.Issuer options:NSCaseInsensitiveSearch])
                {
                    continue;
                }
                
                if (nil == str_cert_serial_number || NSOrderedSame == [str_cert_serial_number compare:@"" options:NSCaseInsensitiveSearch])
                {
                    if (nil == str_cert_theme || NSOrderedSame == [str_cert_theme compare:@"" options:NSCaseInsensitiveSearch])
                    {
                        isadd = true;
                    }
                    else
                    {
                        if(NSOrderedSame != [str_cert_theme compare:item.m_info.Subject options:NSCaseInsensitiveSearch])
                        {
                            continue;
                        }
                        isadd = true;
                    }
                }
                else
                {
                    if(NSOrderedSame != [str_cert_serial_number compare:item.m_info.SerialNumber options:NSCaseInsensitiveSearch])
                    {
                        continue;
                    }
                    
                    if (nil == str_cert_theme || NSOrderedSame == [str_cert_theme compare:@"" options:NSCaseInsensitiveSearch])
                    {
                        isadd = true;
                    }
                    else
                    {
                        if(NSOrderedSame != [str_cert_theme compare:item.m_info.Subject options:NSCaseInsensitiveSearch])
                        {
                            continue;
                        }
                        isadd = true;
                    }
                }
            }
            
            if (isadd) {
                rv = CERT_CertTimesValid(cert);
                
                
                if (SECSuccess == rv) {
                    item.m_info.Verify = @"YES";
                }
                else
                {
                    item.m_info.Verify = @"NO";
                }
                
                
                switch (i_cert_status) {
                    case ECertAll:
                        break;
                    case ECertValid:
                        if (SECSuccess == rv) {
                            ;
                        }
                        else
                        {
                            isadd = false;
                        }
                        break;
                    case ECertShuldUpdate:
                        if (SECSuccess == rv) {
                            PRTime remind = notAfter - PR_Now();
                            
                            if ((int)(remind/24/60/60/1000000) < i_cert_update_remain_days) {
                                ;
                            }
                            else
                            {
                                isadd = false;
                            }
                        }
                        else
                        {
                            isadd = false;
                        }
                        break;
                    case ECertInValid:
                        if (SECSuccess == rv) {
                            isadd = false;
                        }
                        else
                        {
                            ;
                        }
                        break;
                        
                    default:
                        break;
                }
            }
            
            if (isadd)
            {
                [s_array_cert_table addObject:item];
                [*str_cert_id addObject:item.m_id];
                i++;
            }
	    }
	}
    
    if (certs) {
        CERT_DestroyCertList(certs);
    }
    
    if (slot) {
        PK11_FreeSlot(slot);
    }
    
    rv = NSS_Shutdown();
    
    return EStateSuccess;
}



int certExpireRemind(OUT int * str_time_remind, IN const NSString * str_cert_id)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    
    if (NULL == str_time_remind || nil == str_cert_id || nil == s_array_cert_table)
    {
        setLastErrInfo(EStateErrorInvalidArg);
        
        return EStateErrorInvalidArg;
    }
    
    if ([str_cert_id intValue] >= [s_array_cert_table count])
    {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    CertInfoClass * info = [s_array_cert_table objectAtIndex:[str_cert_id intValue]];
    
    
    PRTime remind = info.m_notAfter - PR_Now();
    
    
    *str_time_remind =  (int)(remind/24/60/60/1000000);
    
    return EStateSuccess;
}


int getCertSubject(OUT NSString * * str_cert_theme, IN const NSString * str_cert_id)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    
    if (nil == str_cert_id  || nil == s_array_cert_table || nil == str_cert_theme)
    {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    if ([str_cert_id intValue] >= [s_array_cert_table count])
    {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    CertInfoClass * info = [s_array_cert_table objectAtIndex:[str_cert_id intValue]];
    
    * str_cert_theme = info.m_info.Subject;
    
    return EStateSuccess;
}


int getCertSerialNumber(OUT NSString * * str_cert_serial_number, IN const NSString * str_cert_id)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    
    if (nil == str_cert_id  || nil == s_array_cert_table || nil == str_cert_serial_number)
    {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    if ([str_cert_id intValue] >= [s_array_cert_table count])
    {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    
    CertInfoClass * info = [s_array_cert_table objectAtIndex:[str_cert_id intValue]];
    
    * str_cert_serial_number = info.m_info.SerialNumber;
    
    return EStateSuccess;
}

int getCertNickName(OUT NSString * * str_cert_nickname, IN const NSString * str_cert_id)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    
    if (nil == str_cert_id  || nil == s_array_cert_table || nil == str_cert_nickname)
    {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    if ([str_cert_id intValue] >= [s_array_cert_table count])
    {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    
    CertInfoClass * info = [s_array_cert_table objectAtIndex:[str_cert_id intValue]];
    
    * str_cert_nickname = info.m_nick_name;
    
    return EStateSuccess;
}


int getCertAttribute(OUT certInfo * * ptr_cert_info, IN const NSString * str_cert_id)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    
    if (nil == str_cert_id  || nil == s_array_cert_table || nil == ptr_cert_info)
    {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    if ([str_cert_id intValue] >= [s_array_cert_table count])
    {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    CertInfoClass * info = [s_array_cert_table objectAtIndex:[str_cert_id intValue]];
    
    * ptr_cert_info = info.m_info;
    
    return EStateSuccess;
}


int getCertBuf(OUT NSString * * str_cert, IN const NSString * str_cert_id)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    
    if (nil == str_cert_id  || nil == s_array_cert_table || nil == str_cert)
    {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    if ([str_cert_id intValue] >= [s_array_cert_table count])
    {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    
    if (false == s_user_pin_flag)
    {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorNeedLogin;
    }
    
    CertInfoClass * info = [s_array_cert_table objectAtIndex:[str_cert_id intValue]];
    
    SECStatus rv = 0;
    
    /*初始化数据库*/
    rv = NSS_Initialize(GetSystemDBDir(),
                        "", "",
                        "secmod.db", 0);
    
    if (SECSuccess != rv) {
        setLastErrInfo(EStateErrorInitDB);
        return EStateErrorInitDB;
    }
    
    
    CERTCertDBHandle *certHandle;
    
    
    certHandle = CERT_GetDefaultCertDB();
    
    PK11SlotInfo * slot = PK11_GetInternalKeySlot();
    
    
    if (NULL == slot) {
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoSlot);
        return EStateErrorNoSlot;
    }
    
    rv = PK11_CheckUserPassword(slot, s_user_pin_data);
    
    if (SECSuccess != rv)
    {
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorPIN);
        return EStateErrorPIN;
    }
    
    CERTCertificate * cert = NULL;
    /*用nickname查找数据库证书*/
    
    const char * nickname = [info.m_nick_name UTF8String];
    
    cert = CERT_FindCertByNicknameOrEmailAddr(certHandle, nickname);
    
    if (NULL == cert) {
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoCert);
        return EStateErrorNoCert;
    }
    
    CERTCertList * certs = NULL;
    CERTCertListNode *node = NULL;
    
    certs = CERT_CreateSubjectCertList(NULL, certHandle, &cert->derSubject,
                                       PR_Now(), PR_FALSE);
    
    if (NULL == certs) {
        CERT_DestroyCertificate(cert);
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoCert);
        return EStateErrorNoCert;
    }
    
    
	CERT_DestroyCertificate(cert);
    cert = NULL;
    
    NSMutableData * data = [[NSMutableData alloc] init];
    
    
	for (node = CERT_LIST_HEAD(certs); !CERT_LIST_END(node,certs);
         node = CERT_LIST_NEXT(node)) {
        [data appendBytes:node->cert->derCert.data length:node->cert->derCert.len];
	}
    
    * str_cert = [GTMBase64 stringByEncodingData:data];
    
    CERT_DestroyCertList(certs);
    
    PK11_FreeSlot(slot);
    NSS_Shutdown();
    
    return EStateSuccess;
}



int signMessage(OUT NSString * * str_sign_out, IN const NSString * str_sign_in, IN const NSString * str_cert_id, IN const NSString * str_hash_alg, IN int i_sign_form)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    
    /*生成证书请求 需要登陆*/
    if (false == s_user_pin_flag)
    {
        setLastErrInfo(EStateErrorNeedLogin);
        return EStateErrorNeedLogin;
    }
    
    if (nil == str_sign_out || nil == str_sign_in || nil == str_cert_id  || nil == s_array_cert_table) {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    if ([str_cert_id intValue] >= [s_array_cert_table count])
    {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    int hashlen = 0;
    int hashOid = 0;
    
    if (NSOrderedSame == [str_hash_alg compare:@"SHA1" options:NSCaseInsensitiveSearch])
    {
        hashOid = SEC_OID_SHA1;
        
    }
    else if (NSOrderedSame == [str_hash_alg compare:@"SM3" options:NSCaseInsensitiveSearch])
    {
        hashOid = SEC_OID_SM3;
    }
    else
    {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    hashlen = HASH_ResultLenByOidTag(hashOid);
    
    CertInfoClass * info = [s_array_cert_table objectAtIndex:[str_cert_id intValue]];
    
    SECStatus rv = 0;
    
    /*初始化数据库*/
    rv = NSS_Initialize(GetSystemDBDir(),
                        "", "",
                        "secmod.db", 0);
    
    if (SECSuccess != rv) {
        setLastErrInfo(EStateErrorInitDB);
        return EStateErrorInitDB;
    }
    
    
    CERTCertDBHandle *certHandle;
    
    
    certHandle = CERT_GetDefaultCertDB();
    
    PK11SlotInfo * slot = PK11_GetInternalKeySlot();
    
    
    if (NULL == slot) {
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoSlot);
        return EStateErrorNoSlot;
    }
    
    rv = PK11_CheckUserPassword(slot, s_user_pin_data);
    
    if (SECSuccess != rv)
    {
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorPIN);
        return EStateErrorPIN;
    }
    
    CERTCertificate * cert = NULL;
    /*用nickname查找数据库证书*/
    
    const char * nickname = [info.m_nick_name UTF8String];
    
    cert = CERT_FindCertByNicknameOrEmailAddr(certHandle, nickname);
    
    if (NULL == cert) {
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoCert);
        return EStateErrorNoCert;
    }
    
    unsigned char hasharray[hashlen];
    
    SECItem sign_hash;
    
    sign_hash.type = 0;
    sign_hash.data = hasharray;
    sign_hash.len = hashlen;
    
    rv = PK11_HashBuf(hashOid,sign_hash.data, (unsigned char *)[str_sign_in UTF8String], strlen([str_sign_in UTF8String]));

    
    if (SECSuccess != rv)
    {
        CERT_DestroyCertificate(cert);
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorHashData);
        return EStateErrorHashData;
    }
    
    if (ESignWithP7Detach == i_sign_form) {
        SEC_PKCS7ContentInfo *cinfo = NULL;
        
        SECCertificateUsage certificateUsage = cert->keyUsage;
        SECCertUsage certUsage = 0;
        
        
        if (certificateUsage & (1<<certUsageObjectSigner))
        {
            certUsage = certUsageObjectSigner;
        }
        else
        {
            certificateUsage = certificateUsage&((1<<certUsageProtectedObjectSigner)^~0);
            certificateUsage = certificateUsage&((1<<certUsageUserCertImport)^~0);
            
            /* ensure we obtained a single usage bit only */
            //        if (!(certificateUsage & (certificateUsage - 1))) {
            //
            //            CERT_DestroyCertificate(cert);
            //            PK11_FreeSlot(slot);
            //            NSS_Shutdown();
            //
            //            return EStateErrorKeyUsage;
            //        }
            
            /* convert SECertificateUsage (bit mask) to SECCertUsage (enum) */
            while (0 != (certificateUsage = certificateUsage >> 1))
            {
                certUsage++;
            }
        }
        
        cinfo = SEC_PKCS7CreateSignedData (cert, certUsage, certHandle,
                                           hashOid,
                                           &sign_hash,
                                           NULL, NULL);
        
        if (NULL == cinfo) {
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorCreateSignedData);
            return EStateErrorCreateSignedData;
        }
        
        rv = SEC_PKCS7IncludeCertChain (cinfo, NULL);
        
        
        
        if (SECSuccess != rv) {
            SEC_PKCS7DestroyContentInfo (cinfo);
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorIncludeCertChain);
            return EStateErrorIncludeCertChain;
        }
        
        //        rv = SEC_PKCS7AddCertificate(cinfo, cert);
        //        if (SECSuccess != rv) {
        //            SEC_PKCS7DestroyContentInfo (cinfo);
        //            CERT_DestroyCertificate(cert);
        //            PK11_FreeSlot(slot);
        //            NSS_Shutdown();
        //
        //            setLastErrInfo(EStateErrorAddCertificate);
        //            return EStateErrorAddCertificate;
        //        }
        
        
        SECItem * item = SEC_PKCS7EncodeItem(NULL,NULL,cinfo,NULL, NULL, NULL);
        
        if (NULL == item) {
            SEC_PKCS7DestroyContentInfo (cinfo);
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorEncodeItem);
            return EStateErrorEncodeItem;
        }
        
        * str_sign_out = [GTMBase64 stringByEncodingBytes:item->data length:item->len];
        
        SECITEM_FreeItem(item, TRUE);
        
        SEC_PKCS7DestroyContentInfo (cinfo);
    }
    else if(ESignWithP7Attach == i_sign_form)
    {
        SEC_PKCS7ContentInfo *cinfo = NULL;
        
        SECCertificateUsage certificateUsage = cert->keyUsage;
        SECCertUsage certUsage = 0;
        
        
        if (certificateUsage & (1<<certUsageObjectSigner))
        {
            certUsage = certUsageObjectSigner;
        }
        else
        {
            certificateUsage = certificateUsage&((1<<certUsageProtectedObjectSigner)^~0);
            certificateUsage = certificateUsage&((1<<certUsageUserCertImport)^~0);
            
            /* ensure we obtained a single usage bit only */
            //        if (!(certificateUsage & (certificateUsage - 1))) {
            //
            //            CERT_DestroyCertificate(cert);
            //            PK11_FreeSlot(slot);
            //            NSS_Shutdown();
            //
            //            return EStateErrorKeyUsage;
            //        }
            
            /* convert SECertificateUsage (bit mask) to SECCertUsage (enum) */
            while (0 != (certificateUsage = certificateUsage >> 1))
            {
                certUsage++;
            }
        }
        
        cinfo = SEC_PKCS7CreateSignedData (cert, certUsage, certHandle,
                                           hashOid,
                                           NULL,
                                           NULL, NULL);
        
        
        if (NULL == cinfo) {
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorCreateSignedData);
            return EStateErrorCreateSignedData;
        }
        
        rv = SEC_PKCS7SetContent(cinfo, (void *)([str_sign_in UTF8String]), strlen([str_sign_in UTF8String]));
        
        if (SECSuccess != rv) {
            SEC_PKCS7DestroyContentInfo (cinfo);
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorSetContent);
            return EStateErrorSetContent;
        }
        
        rv = SEC_PKCS7IncludeCertChain (cinfo, NULL);
        
        if (SECSuccess != rv) {
            SEC_PKCS7DestroyContentInfo (cinfo);
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorIncludeCertChain);
            return EStateErrorIncludeCertChain;
        }
        
        //        rv = SEC_PKCS7AddCertificate(cinfo, cert);
        //        if (SECSuccess != rv) {
        //            SEC_PKCS7DestroyContentInfo (cinfo);
        //            CERT_DestroyCertificate(cert);
        //            PK11_FreeSlot(slot);
        //            NSS_Shutdown();
        //
        //            setLastErrInfo(EStateErrorAddCertificate);
        //            return EStateErrorAddCertificate;
        //        }
        
        
        SECItem * item = SEC_PKCS7EncodeItem(NULL,NULL,cinfo,NULL, NULL, NULL);
        
        if (NULL == item) {
            SEC_PKCS7DestroyContentInfo (cinfo);
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorEncodeItem);
            return EStateErrorEncodeItem;
        }
        
        * str_sign_out = [GTMBase64 stringByEncodingBytes:item->data length:item->len];
        
        
        
        SECITEM_FreeItem(item, TRUE);
        
        SEC_PKCS7DestroyContentInfo (cinfo);
    }
    else
    {
        
        SECItem sign_out;
        
        
        unsigned char dataOUT[256] = {0};
        
        sign_out.data = dataOUT;
        sign_out.len = 256;

        
        SECKEYPrivateKey *prvkey = NULL;
        
        prvkey = PK11_FindKeyByAnyCert(cert, NULL);
        
        if (NULL == prvkey)
        {
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorNoPriKey);
            return EStateErrorNoPriKey;
        }
        
        rv = PK11_Sign(prvkey, &sign_out, &sign_hash);
        
        if (SECSuccess != rv)
        {
            SECKEY_DestroyPrivateKey(prvkey);
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorSignData);
            return EStateErrorSignData;
        }
        
        * str_sign_out = [GTMBase64 stringByEncodingBytes:sign_out.data length:sign_out.len];
        
        if (prvkey)
        {
            SECKEY_DestroyPrivateKey(prvkey);
        }
    }
    
    
    if (cert)
    {
        CERT_DestroyCertificate(cert);
    }
    
    
    PK11_FreeSlot(slot);
    NSS_Shutdown();
    
    return EStateSuccess;
}




int signMessageGBK(OUT NSString * * str_sign_out, IN const NSString * str_sign_in, IN const NSString * str_cert_id, IN const NSString * str_hash_alg, IN int i_sign_form)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    
    /*生成证书请求 需要登陆*/
    if (false == s_user_pin_flag)
    {
        setLastErrInfo(EStateErrorNeedLogin);
        return EStateErrorNeedLogin;
    }
    
    if (nil == str_sign_out || nil == str_sign_in || nil == str_cert_id  || nil == s_array_cert_table) {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    if ([str_cert_id intValue] >= [s_array_cert_table count])
    {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    int hashlen = 0;
    int hashOid = 0;
    
    if (NSOrderedSame == [str_hash_alg compare:@"SHA1" options:NSCaseInsensitiveSearch])
    {
        hashOid = SEC_OID_SHA1;
        
    }
    else if (NSOrderedSame == [str_hash_alg compare:@"SM3" options:NSCaseInsensitiveSearch])
    {
        hashOid = SEC_OID_SM3;
    }
    else
    {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    hashlen = HASH_ResultLenByOidTag(hashOid);
    
    CertInfoClass * info = [s_array_cert_table objectAtIndex:[str_cert_id intValue]];
    
    SECStatus rv = 0;
    
    /*初始化数据库*/
    rv = NSS_Initialize(GetSystemDBDir(),
                        "", "",
                        "secmod.db", 0);
    
    if (SECSuccess != rv) {
        setLastErrInfo(EStateErrorInitDB);
        return EStateErrorInitDB;
    }
    
    
    CERTCertDBHandle *certHandle;
    
    
    certHandle = CERT_GetDefaultCertDB();
    
    PK11SlotInfo * slot = PK11_GetInternalKeySlot();
    
    
    if (NULL == slot) {
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoSlot);
        return EStateErrorNoSlot;
    }
    
    rv = PK11_CheckUserPassword(slot, s_user_pin_data);
    
    if (SECSuccess != rv)
    {
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorPIN);
        return EStateErrorPIN;
    }
    
    CERTCertificate * cert = NULL;
    /*用nickname查找数据库证书*/
    
    const char * nickname = [info.m_nick_name UTF8String];
    
    cert = CERT_FindCertByNicknameOrEmailAddr(certHandle, nickname);
    
    if (NULL == cert) {
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoCert);
        return EStateErrorNoCert;
    }
    
    unsigned char hasharray[hashlen];
    
    SECItem sign_hash;
    
    sign_hash.type = 0;
    sign_hash.data = hasharray;
    sign_hash.len = hashlen;
    
    
    
    NSStringEncoding gbk = CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingDOSChineseSimplif);
    NSData * dataGBK = [str_sign_in dataUsingEncoding:gbk];
    
    
    rv = PK11_HashBuf(hashOid,sign_hash.data, (unsigned char *)[dataGBK bytes], [dataGBK length]);
    
    //rv = PK11_HashBuf(hashOid,sign_hash.data, (unsigned char *)[str_sign_in UTF8String], strlen([str_sign_in UTF8String]));
    
    
    if (SECSuccess != rv)
    {
        CERT_DestroyCertificate(cert);
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorHashData);
        return EStateErrorHashData;
    }
    
    if (ESignWithP7Detach == i_sign_form) {
        SEC_PKCS7ContentInfo *cinfo = NULL;
        
        SECCertificateUsage certificateUsage = cert->keyUsage;
        SECCertUsage certUsage = 0;
        
        
        if (certificateUsage & (1<<certUsageObjectSigner))
        {
            certUsage = certUsageObjectSigner;
        }
        else
        {
            certificateUsage = certificateUsage&((1<<certUsageProtectedObjectSigner)^~0);
            certificateUsage = certificateUsage&((1<<certUsageUserCertImport)^~0);
            
            /* ensure we obtained a single usage bit only */
            //        if (!(certificateUsage & (certificateUsage - 1))) {
            //
            //            CERT_DestroyCertificate(cert);
            //            PK11_FreeSlot(slot);
            //            NSS_Shutdown();
            //
            //            return EStateErrorKeyUsage;
            //        }
            
            /* convert SECertificateUsage (bit mask) to SECCertUsage (enum) */
            while (0 != (certificateUsage = certificateUsage >> 1))
            {
                certUsage++;
            }
        }
        
        cinfo = SEC_PKCS7CreateSignedData (cert, certUsage, certHandle,
                                           hashOid,
                                           &sign_hash,
                                           NULL, NULL);
        
        if (NULL == cinfo) {
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorCreateSignedData);
            return EStateErrorCreateSignedData;
        }
        
        rv = SEC_PKCS7IncludeCertChain (cinfo, NULL);
        
        
        
        if (SECSuccess != rv) {
            SEC_PKCS7DestroyContentInfo (cinfo);
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorIncludeCertChain);
            return EStateErrorIncludeCertChain;
        }
        
        //        rv = SEC_PKCS7AddCertificate(cinfo, cert);
        //        if (SECSuccess != rv) {
        //            SEC_PKCS7DestroyContentInfo (cinfo);
        //            CERT_DestroyCertificate(cert);
        //            PK11_FreeSlot(slot);
        //            NSS_Shutdown();
        //
        //            setLastErrInfo(EStateErrorAddCertificate);
        //            return EStateErrorAddCertificate;
        //        }
        
        
        SECItem * item = SEC_PKCS7EncodeItem(NULL,NULL,cinfo,NULL, NULL, NULL);
        
        if (NULL == item) {
            SEC_PKCS7DestroyContentInfo (cinfo);
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorEncodeItem);
            return EStateErrorEncodeItem;
        }
        
        * str_sign_out = [GTMBase64 stringByEncodingBytes:item->data length:item->len];
        
        SECITEM_FreeItem(item, TRUE);
        
        SEC_PKCS7DestroyContentInfo (cinfo);
    }
    else if(ESignWithP7Attach == i_sign_form)
    {
        SEC_PKCS7ContentInfo *cinfo = NULL;
        
        SECCertificateUsage certificateUsage = cert->keyUsage;
        SECCertUsage certUsage = 0;
        
        
        if (certificateUsage & (1<<certUsageObjectSigner))
        {
            certUsage = certUsageObjectSigner;
        }
        else
        {
            certificateUsage = certificateUsage&((1<<certUsageProtectedObjectSigner)^~0);
            certificateUsage = certificateUsage&((1<<certUsageUserCertImport)^~0);
            
            /* ensure we obtained a single usage bit only */
            //        if (!(certificateUsage & (certificateUsage - 1))) {
            //
            //            CERT_DestroyCertificate(cert);
            //            PK11_FreeSlot(slot);
            //            NSS_Shutdown();
            //
            //            return EStateErrorKeyUsage;
            //        }
            
            /* convert SECertificateUsage (bit mask) to SECCertUsage (enum) */
            while (0 != (certificateUsage = certificateUsage >> 1))
            {
                certUsage++;
            }
        }
        
        cinfo = SEC_PKCS7CreateSignedData (cert, certUsage, certHandle,
                                           hashOid,
                                           NULL,
                                           NULL, NULL);
        
        
        if (NULL == cinfo) {
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorCreateSignedData);
            return EStateErrorCreateSignedData;
        }
        
        rv = SEC_PKCS7SetContent(cinfo, (void *)([str_sign_in UTF8String]), strlen([str_sign_in UTF8String]));
        
        if (SECSuccess != rv) {
            SEC_PKCS7DestroyContentInfo (cinfo);
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorSetContent);
            return EStateErrorSetContent;
        }
        
        rv = SEC_PKCS7IncludeCertChain (cinfo, NULL);
        
        if (SECSuccess != rv) {
            SEC_PKCS7DestroyContentInfo (cinfo);
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorIncludeCertChain);
            return EStateErrorIncludeCertChain;
        }
        
        //        rv = SEC_PKCS7AddCertificate(cinfo, cert);
        //        if (SECSuccess != rv) {
        //            SEC_PKCS7DestroyContentInfo (cinfo);
        //            CERT_DestroyCertificate(cert);
        //            PK11_FreeSlot(slot);
        //            NSS_Shutdown();
        //
        //            setLastErrInfo(EStateErrorAddCertificate);
        //            return EStateErrorAddCertificate;
        //        }
        
        
        SECItem * item = SEC_PKCS7EncodeItem(NULL,NULL,cinfo,NULL, NULL, NULL);
        
        if (NULL == item) {
            SEC_PKCS7DestroyContentInfo (cinfo);
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorEncodeItem);
            return EStateErrorEncodeItem;
        }
        
        * str_sign_out = [GTMBase64 stringByEncodingBytes:item->data length:item->len];
        
        
        
        SECITEM_FreeItem(item, TRUE);
        
        SEC_PKCS7DestroyContentInfo (cinfo);
    }
    else
    {
        
        SECItem sign_out;
        
        
        unsigned char dataOUT[256] = {0};
        
        sign_out.data = dataOUT;
        sign_out.len = 256;
        
        
        SECKEYPrivateKey *prvkey = NULL;
        
        prvkey = PK11_FindKeyByAnyCert(cert, NULL);
        
        if (NULL == prvkey)
        {
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorNoPriKey);
            return EStateErrorNoPriKey;
        }
        
        rv = PK11_Sign(prvkey, &sign_out, &sign_hash);
        
        if (SECSuccess != rv)
        {
            SECKEY_DestroyPrivateKey(prvkey);
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorSignData);
            return EStateErrorSignData;
        }
        
        * str_sign_out = [GTMBase64 stringByEncodingBytes:sign_out.data length:sign_out.len];
        
        if (prvkey)
        {
            SECKEY_DestroyPrivateKey(prvkey);
        }
    }
    
    
    if (cert)
    {
        CERT_DestroyCertificate(cert);
    }
    
    
    PK11_FreeSlot(slot);
    NSS_Shutdown();
    
    return EStateSuccess;
}






int verifyMessageGBK(IN const NSString * str_sign_in, IN const NSString * str_sign_out, IN const NSString * str_cert_id, IN const NSString * str_hash_alg, IN int i_sign_form)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    
    if (nil == str_sign_out || nil == str_sign_in || nil == str_cert_id  || nil == s_array_cert_table) {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    if ([str_cert_id intValue] >= [s_array_cert_table count])
    {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    int hashlen = 0;
    int hashOid = 0;
    int hashType = 0;
    
    if (NSOrderedSame == [str_hash_alg compare:@"SHA1" options:NSCaseInsensitiveSearch])
    {
        hashOid = SEC_OID_SHA1;
        hashType = HASH_AlgSHA1;
        
    }
    else if (NSOrderedSame == [str_hash_alg compare:@"SM3" options:NSCaseInsensitiveSearch])
    {
        hashOid = SEC_OID_SM3;
        hashType = HASH_AlgSM3;
    }
    else
    {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    hashlen = HASH_ResultLenByOidTag(hashOid);
    
    NSData * data = [GTMBase64 decodeString:(NSString *)str_sign_out];
    
    if(nil == data)
    {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    CertInfoClass * info = [s_array_cert_table objectAtIndex:[str_cert_id intValue]];
    
    SECStatus rv = 0;
    
    /*初始化数据库*/
    rv = NSS_Initialize(GetSystemDBDir(),
                        "", "",
                        "secmod.db", 0);
    
    if (SECSuccess != rv) {
        setLastErrInfo(EStateErrorInitDB);
        return EStateErrorInitDB;
    }
    
    
    CERTCertDBHandle *certHandle;
    
    
    certHandle = CERT_GetDefaultCertDB();
    
    PK11SlotInfo * slot = PK11_GetInternalKeySlot();
    
    
    if (NULL == slot) {
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoSlot);
        return EStateErrorNoSlot;
    }
    
    CERTCertificate * cert = NULL;
    /*用nickname查找数据库证书*/
    
    const char * nickname = [info.m_nick_name UTF8String];
    
    cert = CERT_FindCertByNicknameOrEmailAddr(certHandle, nickname);
    
    if (NULL == cert) {
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoCert);
        
        return EStateErrorNoCert;
    }
    
    SECItem sign_out;
    
    sign_out.type = 0;
    sign_out.data = (unsigned char *)data.bytes;
    sign_out.len = [data length];
    
    unsigned char hasharray[hashlen];
    
    SECItem sign_hash;
    
    sign_hash.type = 0;
    sign_hash.data = hasharray;
    sign_hash.len = hashlen;
    
    
    NSStringEncoding gbk = CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingDOSChineseSimplif);
    NSData * dataGBK = [str_sign_in dataUsingEncoding:gbk];
    
    
    rv = PK11_HashBuf(hashOid,sign_hash.data, (unsigned char *)[dataGBK bytes], [dataGBK length]);
    
//    rv = PK11_HashBuf(hashOid,sign_hash.data, (unsigned char *)[str_sign_in UTF8String], strlen([str_sign_in UTF8String]));
    
    if (SECSuccess != rv)
    {
        CERT_DestroyCertificate(cert);
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorHashData);
        return EStateErrorHashData;
    }
    
    
    if (ESignWithP7Detach == i_sign_form) {
        SEC_PKCS7ContentInfo *cinfo = NULL;
        
        SECCertificateUsage certificateUsage = cert->keyUsage;
        SECCertUsage certUsage = 0;
        
        
        
        if (certificateUsage & (1<<certUsageObjectSigner))
        {
            certUsage = certUsageObjectSigner;
        }
        else
        {
            certificateUsage = certificateUsage&((1<<certUsageProtectedObjectSigner)^~0);
            certificateUsage = certificateUsage&((1<<certUsageUserCertImport)^~0);
            
            /* ensure we obtained a single usage bit only */
            //        if (!(certificateUsage & (certificateUsage - 1))) {
            //
            //            CERT_DestroyCertificate(cert);
            //            PK11_FreeSlot(slot);
            //            NSS_Shutdown();
            //
            //            return EStateErrorKeyUsage;
            //        }
            
            /* convert SECertificateUsage (bit mask) to SECCertUsage (enum) */
            while (0 != (certificateUsage = certificateUsage >> 1))
            {
                certUsage++;
            }
        }
        
        SECItem item;
        
        item.data = (void *)[data bytes];
        item.len = [data length];
        
        cinfo = SEC_PKCS7DecodeItem(&item, NULL,NULL,NULL,NULL,NULL,NULL,NULL);
        
        if (NULL == cinfo) {
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorDecodeItem);
            return EStateErrorDecodeItem;
        }
        
        //        rv = SEC_PKCS7IncludeCertChain (cinfo, NULL);
        
        if (!SEC_PKCS7VerifyDetachedSignature(cinfo, certUsage, &sign_hash, hashType,
                                              PR_FALSE))
        {
            SEC_PKCS7DestroyContentInfo (cinfo);
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorVerifyDetachedSignature);
            return EStateErrorVerifyDetachedSignature;
        }
        
        
        SEC_PKCS7DestroyContentInfo (cinfo);
    }
    else if(ESignWithP7Attach == i_sign_form)
    {
        SEC_PKCS7ContentInfo *cinfo = NULL;
        
        SECCertificateUsage certificateUsage = cert->keyUsage;
        SECCertUsage certUsage = 0;
        
        
        
        if (certificateUsage & (1<<certUsageObjectSigner))
        {
            certUsage = certUsageObjectSigner;
        }
        else
        {
            certificateUsage = certificateUsage&((1<<certUsageProtectedObjectSigner)^~0);
            certificateUsage = certificateUsage&((1<<certUsageUserCertImport)^~0);
            
            /* ensure we obtained a single usage bit only */
            //        if (!(certificateUsage & (certificateUsage - 1))) {
            //
            //            CERT_DestroyCertificate(cert);
            //            PK11_FreeSlot(slot);
            //            NSS_Shutdown();
            //
            //            return EStateErrorKeyUsage;
            //        }
            
            /* convert SECertificateUsage (bit mask) to SECCertUsage (enum) */
            while (0 != (certificateUsage = certificateUsage >> 1))
            {
                certUsage++;
            }
        }
        
        SECItem item;
        
        item.data = (void *)[data bytes];
        item.len = [data length];
        
        cinfo = SEC_PKCS7DecodeItem(&item, NULL,NULL,NULL,NULL,NULL,NULL,NULL);
        
        if (NULL == cinfo) {
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorDecodeItem);
            return EStateErrorDecodeItem;
        }
        
        //        rv = SEC_PKCS7IncludeCertChain (cinfo, NULL);
        
        if (!SEC_PKCS7VerifySignature(cinfo, certUsage,
                                      PR_FALSE)) {
            SEC_PKCS7DestroyContentInfo (cinfo);
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorVerifySignature);
            return EStateErrorVerifySignature;
        }
        
        SEC_PKCS7DestroyContentInfo (cinfo);
    }
    else
    {
        SECKEYPublicKey *  pubkey = CERT_ExtractPublicKey(cert);
        
        if (NULL == pubkey)
        {
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorNoPubKey);
            return EStateErrorNoPubKey;
        }
        
        rv = PK11_Verify(pubkey, &sign_out, &sign_hash, NULL);
        
        if (SECSuccess != rv)
        {
            SECKEY_DestroyPublicKey(pubkey);
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            setLastErrInfo(EStateErrorVerifySign);
            
            return EStateErrorVerifySign;
        }
        
        if (pubkey)
        {
            SECKEY_DestroyPublicKey(pubkey);
        }
    }
    
    if (cert)
    {
        CERT_DestroyCertificate(cert);
    }
    
    
    PK11_FreeSlot(slot);
    NSS_Shutdown();
    
    return EStateSuccess;
}


int verifyMessage(IN const NSString * str_sign_in, IN const NSString * str_sign_out, IN const NSString * str_cert_id, IN const NSString * str_hash_alg, IN int i_sign_form)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    
    if (nil == str_sign_out || nil == str_sign_in || nil == str_cert_id  || nil == s_array_cert_table) {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    if ([str_cert_id intValue] >= [s_array_cert_table count])
    {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    int hashlen = 0;
    int hashOid = 0;
    int hashType = 0;
    
    if (NSOrderedSame == [str_hash_alg compare:@"SHA1" options:NSCaseInsensitiveSearch])
    {
        hashOid = SEC_OID_SHA1;
        hashType = HASH_AlgSHA1;
        
    }
    else if (NSOrderedSame == [str_hash_alg compare:@"SM3" options:NSCaseInsensitiveSearch])
    {
        hashOid = SEC_OID_SM3;
        hashType = HASH_AlgSM3;
    }
    else
    {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    hashlen = HASH_ResultLenByOidTag(hashOid);
    
    NSData * data = [GTMBase64 decodeString:(NSString *)str_sign_out];
    
    if(nil == data)
    {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    CertInfoClass * info = [s_array_cert_table objectAtIndex:[str_cert_id intValue]];
    
    SECStatus rv = 0;
    
    /*初始化数据库*/
    rv = NSS_Initialize(GetSystemDBDir(),
                        "", "",
                        "secmod.db", 0);
    
    if (SECSuccess != rv) {
        setLastErrInfo(EStateErrorInitDB);
        return EStateErrorInitDB;
    }
    
    
    CERTCertDBHandle *certHandle;
    
    
    certHandle = CERT_GetDefaultCertDB();
    
    PK11SlotInfo * slot = PK11_GetInternalKeySlot();
    
    
    if (NULL == slot) {
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoSlot);
        return EStateErrorNoSlot;
    }
    
    CERTCertificate * cert = NULL;
    /*用nickname查找数据库证书*/
    
    const char * nickname = [info.m_nick_name UTF8String];
    
    cert = CERT_FindCertByNicknameOrEmailAddr(certHandle, nickname);
    
    if (NULL == cert) {
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoCert);
        
        return EStateErrorNoCert;
    }
    
    SECItem sign_out;
    
    sign_out.type = 0;
    sign_out.data = (unsigned char *)data.bytes;
    sign_out.len = [data length];
    
    unsigned char hasharray[hashlen];
    
    SECItem sign_hash;
    
    sign_hash.type = 0;
    sign_hash.data = hasharray;
    sign_hash.len = hashlen;
    
    
//    NSStringEncoding gbk = CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingDOSChineseSimplif);
//    NSData * dataGBK = [str_sign_in dataUsingEncoding:gbk];
//    
//    
//    rv = PK11_HashBuf(hashOid,sign_hash.data, (unsigned char *)[dataGBK bytes], [dataGBK length]);
    
    rv = PK11_HashBuf(hashOid,sign_hash.data, (unsigned char *)[str_sign_in UTF8String], strlen([str_sign_in UTF8String]));
    
    if (SECSuccess != rv)
    {
        CERT_DestroyCertificate(cert);
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorHashData);
        return EStateErrorHashData;
    }
    
    
    if (ESignWithP7Detach == i_sign_form) {
        SEC_PKCS7ContentInfo *cinfo = NULL;
        
        SECCertificateUsage certificateUsage = cert->keyUsage;
        SECCertUsage certUsage = 0;
        
        
        
        if (certificateUsage & (1<<certUsageObjectSigner))
        {
            certUsage = certUsageObjectSigner;
        }
        else
        {
            certificateUsage = certificateUsage&((1<<certUsageProtectedObjectSigner)^~0);
            certificateUsage = certificateUsage&((1<<certUsageUserCertImport)^~0);
            
            /* ensure we obtained a single usage bit only */
            //        if (!(certificateUsage & (certificateUsage - 1))) {
            //
            //            CERT_DestroyCertificate(cert);
            //            PK11_FreeSlot(slot);
            //            NSS_Shutdown();
            //
            //            return EStateErrorKeyUsage;
            //        }
            
            /* convert SECertificateUsage (bit mask) to SECCertUsage (enum) */
            while (0 != (certificateUsage = certificateUsage >> 1))
            {
                certUsage++;
            }
        }
        
        SECItem item;
        
        item.data = (void *)[data bytes];
        item.len = [data length];
        
        cinfo = SEC_PKCS7DecodeItem(&item, NULL,NULL,NULL,NULL,NULL,NULL,NULL);
        
        if (NULL == cinfo) {
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorDecodeItem);
            return EStateErrorDecodeItem;
        }
        
        //        rv = SEC_PKCS7IncludeCertChain (cinfo, NULL);
        
        if (!SEC_PKCS7VerifyDetachedSignature(cinfo, certUsage, &sign_hash, hashType,
                                              PR_FALSE))
        {
            SEC_PKCS7DestroyContentInfo (cinfo);
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorVerifyDetachedSignature);
            return EStateErrorVerifyDetachedSignature;
        }
        
        
        SEC_PKCS7DestroyContentInfo (cinfo);
    }
    else if(ESignWithP7Attach == i_sign_form)
    {
        SEC_PKCS7ContentInfo *cinfo = NULL;
        
        SECCertificateUsage certificateUsage = cert->keyUsage;
        SECCertUsage certUsage = 0;
        
        
        
        if (certificateUsage & (1<<certUsageObjectSigner))
        {
            certUsage = certUsageObjectSigner;
        }
        else
        {
            certificateUsage = certificateUsage&((1<<certUsageProtectedObjectSigner)^~0);
            certificateUsage = certificateUsage&((1<<certUsageUserCertImport)^~0);
            
            /* ensure we obtained a single usage bit only */
            //        if (!(certificateUsage & (certificateUsage - 1))) {
            //
            //            CERT_DestroyCertificate(cert);
            //            PK11_FreeSlot(slot);
            //            NSS_Shutdown();
            //
            //            return EStateErrorKeyUsage;
            //        }
            
            /* convert SECertificateUsage (bit mask) to SECCertUsage (enum) */
            while (0 != (certificateUsage = certificateUsage >> 1))
            {
                certUsage++;
            }
        }
        
        SECItem item;
        
        item.data = (void *)[data bytes];
        item.len = [data length];
        
        cinfo = SEC_PKCS7DecodeItem(&item, NULL,NULL,NULL,NULL,NULL,NULL,NULL);
        
        if (NULL == cinfo) {
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorDecodeItem);
            return EStateErrorDecodeItem;
        }
        
        //        rv = SEC_PKCS7IncludeCertChain (cinfo, NULL);
        
        if (!SEC_PKCS7VerifySignature(cinfo, certUsage,
                                      PR_FALSE)) {
            SEC_PKCS7DestroyContentInfo (cinfo);
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorVerifySignature);
            return EStateErrorVerifySignature;
        }
        
        SEC_PKCS7DestroyContentInfo (cinfo);
    }
    else
    {
        SECKEYPublicKey *  pubkey = CERT_ExtractPublicKey(cert);
        
        if (NULL == pubkey)
        {
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorNoPubKey);
            return EStateErrorNoPubKey;
        }
        
        rv = PK11_Verify(pubkey, &sign_out, &sign_hash, NULL);
        
        if (SECSuccess != rv)
        {
            SECKEY_DestroyPublicKey(pubkey);
            CERT_DestroyCertificate(cert);
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            setLastErrInfo(EStateErrorVerifySign);
            
            return EStateErrorVerifySign;
        }
        
        if (pubkey)
        {
            SECKEY_DestroyPublicKey(pubkey);
        }
    }
    
    if (cert)
    {
        CERT_DestroyCertificate(cert);
    }
    
    
    PK11_FreeSlot(slot);
    NSS_Shutdown();
    
    return EStateSuccess;
}



int encryptMessage(OUT NSString * * str_msg_out, IN const NSString * str_msg_in, IN const NSString * str_encryt_alg, IN const NSString * str_cert_id)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    
    if (nil == str_msg_out || nil == str_msg_in || nil == str_cert_id || nil == s_array_cert_table) {
        setLastErrInfo(EStateErrorInvalidArg);
        
        return EStateErrorInvalidArg;
    }
    
    if ([str_cert_id intValue] >= [s_array_cert_table count])
    {
        setLastErrInfo(EStateErrorInvalidArg);
        
        return EStateErrorInvalidArg;
    }
    
    CertInfoClass * info = [s_array_cert_table objectAtIndex:[str_cert_id intValue]];
    
    SECStatus rv = 0;
    
    /*初始化数据库*/
    rv = NSS_Initialize(GetSystemDBDir(),
                        "", "",
                        "secmod.db", 0);
    
    if (SECSuccess != rv) {
        setLastErrInfo(EStateErrorInitDB);
        
        return EStateErrorInitDB;
    }
    
    
    CERTCertDBHandle *certHandle;
    
    
    certHandle = CERT_GetDefaultCertDB();
    
    PK11SlotInfo * slot = PK11_GetInternalKeySlot();
    
    
    if (NULL == slot) {
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoSlot);
        
        return EStateErrorNoSlot;
    }
    
    CERTCertificate * cert = NULL;
    /*用nickname查找数据库证书*/
    
    const char * nickname = [info.m_nick_name UTF8String];
    
    cert = CERT_FindCertByNicknameOrEmailAddr(certHandle, nickname);
    
    if (NULL == cert) {
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoCert);
        return EStateErrorNoCert;
    }
    
    SECKEYPublicKey *  pubkey = CERT_ExtractPublicKey(cert);
    
    if (NULL == pubkey)
    {
        CERT_DestroyCertificate(cert);
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoPubKey);
        return EStateErrorNoPubKey;
    }
    
    unsigned char dataEn[256] = {0};
    
    rv = PK11_PubEncryptPKCS1(pubkey, dataEn, (unsigned char *)[str_msg_in UTF8String], strlen([str_msg_in UTF8String]), NULL);
    
    if (SECSuccess != rv)
    {
        SECKEY_DestroyPublicKey(pubkey);
        CERT_DestroyCertificate(cert);
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorEncrypt);
        return EStateErrorEncrypt;
    }
    
    * str_msg_out = [GTMBase64 stringByEncodingBytes:dataEn length:SECKEY_PublicKeyStrength(pubkey)];
    
    if (cert)
    {
        CERT_DestroyCertificate(cert);
    }
    
    if (pubkey)
    {
        SECKEY_DestroyPublicKey(pubkey);
    }
    
    
    PK11_FreeSlot(slot);
    NSS_Shutdown();
    
    return EStateSuccess;
}



int decryptMessage(OUT NSString * * str_msg_out, IN const NSString * str_msg_in, IN const NSString * str_encryt_alg, IN const NSString * str_cert_id)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    /*解密消息*/
    if (false == s_user_pin_flag)
    {
        setLastErrInfo(EStateErrorNeedLogin);
        return EStateErrorNeedLogin;
    }
    
    if (nil == str_msg_out || nil == str_msg_in || nil == str_cert_id || nil == s_array_cert_table) {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    if ([str_cert_id intValue] >= [s_array_cert_table count])
    {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    NSData * data = [GTMBase64 decodeString:(NSString *)str_msg_in];
    
    if (nil == data) {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    CertInfoClass * info = [s_array_cert_table objectAtIndex:[str_cert_id intValue]];
    
    SECStatus rv = 0;
    
    /*初始化数据库*/
    rv = NSS_Initialize(GetSystemDBDir(),
                        "", "",
                        "secmod.db", 0);
    
    if (SECSuccess != rv) {
        setLastErrInfo(EStateErrorInitDB);
        return EStateErrorInitDB;
    }
    
    
    CERTCertDBHandle *certHandle;
    
    
    certHandle = CERT_GetDefaultCertDB();
    
    PK11SlotInfo * slot = PK11_GetInternalKeySlot();
    
    
    if (NULL == slot) {
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoSlot);
        return EStateErrorNoSlot;
    }
    
    rv = PK11_CheckUserPassword(slot, s_user_pin_data);
    
    if (SECSuccess != rv)
    {
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorPIN);
        
        return EStateErrorPIN;
    }
    
    CERTCertificate * cert = NULL;
    /*用nickname查找数据库证书*/
    
    const char * nickname = [info.m_nick_name UTF8String];
    
    cert = CERT_FindCertByNicknameOrEmailAddr(certHandle, nickname);
    
    if (NULL == cert) {
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoCert);
        
        return EStateErrorNoCert;
    }
    
    SECKEYPrivateKey *prvkey = NULL;
    
    prvkey = PK11_FindKeyByAnyCert(cert, NULL);
    
    if (NULL == prvkey)
    {
        CERT_DestroyCertificate(cert);
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoPriKey);
        
        return EStateErrorNoPriKey;
    }
    
    
    unsigned char dataDe[256] = {0};
    
    int lenOut = 256;
    
    rv = PK11_PrivDecryptPKCS1(prvkey,  dataDe, (unsigned *)&lenOut,256, (unsigned char *)[data bytes], [data length]);
    
    if (SECSuccess != rv)
    {
        CERT_DestroyCertificate(cert);
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorDecrypt);
        
        return EStateErrorDecrypt;
    }
    
    * str_msg_out = [[NSString alloc] initWithCString:(char *)dataDe encoding:NSUTF8StringEncoding];
    
    if (cert)
    {
        CERT_DestroyCertificate(cert);
    }
    
    if (prvkey)
    {
        SECKEY_DestroyPrivateKey(prvkey);
    }
    
    
    PK11_FreeSlot(slot);
    NSS_Shutdown();
    
    return EStateSuccess;
}



int enumKey( OUT NSMutableArray * * str_dev_id)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    
    if (nil == str_dev_id) {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    SECStatus rv = 0;
    
    * str_dev_id = [[NSMutableArray alloc] init];
    
    /*初始化数据库*/
    rv = NSS_Initialize(GetSystemDBDir(),
                        "", "",
                        "secmod.db", 0);
    
    if (SECSuccess != rv) {
        setLastErrInfo(EStateErrorInitDB);
        return EStateErrorInitDB;
    }
    
    PK11SlotInfo * slot = PK11_GetInternalKeySlot();
    
    if (slot) {
        int iSlotID = PK11_GetSlotID(slot);
        
        NSString * strSlotID = [NSString stringWithFormat:@"%d", iSlotID];
        
        if (nil != str_dev_id) {
            [* str_dev_id addObject:strSlotID];
        }
        
        PK11_FreeSlot(slot);
    }
    
    rv = NSS_Shutdown();
    
    return EStateSuccess;
}



int genCSR( OUT NSString * * str_cert_req, IN const NSString * str_dev_name, IN const NSString * str_name, IN const NSString * str_email, IN const NSString * str_department, IN const NSString * str_unit, IN int i_prikey_len, IN const NSString * str_prikey_type)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    
    /*生成证书请求 需要登陆*/
    if (false == s_user_pin_flag)
    {
        setLastErrInfo(EStateErrorNeedLogin);
        return EStateErrorNeedLogin;
    }
    
    if (nil == str_cert_req) {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    int size = 0;
    int publicExponent = 65537;
    int keytype = rsaKey;
    
    if (NSOrderedSame == [str_prikey_type compare:@"RSA" options:NSCaseInsensitiveSearch])
    {
        if (1024 != i_prikey_len && 2048!= i_prikey_len) {
            setLastErrInfo(EStateErrorInvalidArg);
            return EStateErrorInvalidArg;
        }
        keytype = rsaKey;
    }
    else if (NSOrderedSame == [str_prikey_type compare:@"SM2" options:NSCaseInsensitiveSearch])
    {
        if (256 != i_prikey_len) {
            setLastErrInfo(EStateErrorInvalidArg);
            return EStateErrorInvalidArg;
        }
        keytype = ecKey;
    }
    else
    {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    size = i_prikey_len;
    
    CERTName *  subject = 0;
    
    NSMutableString * strSubject = [[NSMutableString alloc] init];
    
    if (str_name && 0 < [str_name length]) {
        [strSubject appendFormat:@"CN=%@", str_name];
    }
    
    if (str_email && 0 < [str_email length])
    {
        [strSubject appendFormat:@", E=%@", str_email];
    }
    
    if (str_department && 0 < [str_department length])
    {
        [strSubject appendFormat:@", OU=%@", str_department];
    }
    
    if (str_unit && 0 < [str_unit length])
    {
        [strSubject appendFormat:@", O=%@", str_unit];
    }
    
    subject = CERT_AsciiToName([strSubject UTF8String]);
    
    
    if (NULL == subject) {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    SECStatus rv = 0;
    
    /*初始化数据库*/
    rv = NSS_Initialize(GetSystemDBDir(),
                        "", "",
                        "secmod.db", 0);
    
    if (SECSuccess != rv) {
        CERT_DestroyName(subject);
        
        setLastErrInfo(EStateErrorInitDB);
        return EStateErrorInitDB;
    }
    
    
    //    CERTCertDBHandle *certHandle;
    //
    //    certHandle = CERT_GetDefaultCertDB();
    
    PK11SlotInfo * slot = PK11_GetInternalKeySlot();
    
    
    if (NULL == slot) {
        CERT_DestroyName(subject);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoSlot);
        
        return EStateErrorNoSlot;
    }
    
    switch (keytype) {
        case rsaKey:
        {
            PK11RSAGenParams   rsaparams;
            void             * params;
            
            rsaparams.keySizeInBits = size;
            rsaparams.pe = publicExponent;
            params = &rsaparams;
            
            SECKEYPrivateKey *prvkey = NULL;
            SECKEYPublicKey *pubkey = NULL;
            
            rv = PK11_CheckUserPassword(slot, s_user_pin_data);
            
            if (SECSuccess != rv) {
                CERT_DestroyName(subject);
                PK11_FreeSlot(slot);
                NSS_Shutdown();
                
                setLastErrInfo(EStateErrorPIN);
                return EStateErrorPIN;
            }
            
            prvkey = PK11_GenerateKeyPair(slot, CKM_RSA_PKCS_KEY_PAIR_GEN, params, &pubkey,
                                          PR_TRUE /*isPerm*/, PR_TRUE /*isSensitive*/,
                                          NULL /*wincx*/);
            
            if (NULL == prvkey)
            {
                CERT_DestroyName(subject);
                PK11_FreeSlot(slot);
                NSS_Shutdown();
                
                setLastErrInfo(EStateErrorGenPriKey);
                return EStateErrorGenPriKey;
            }
            
            time_t now;
            time(&now);
            
            NSDate *_dateline = [NSDate dateWithTimeIntervalSince1970:now];
            NSDateFormatter *dateformat=[[NSDateFormatter alloc] init];
            [dateformat setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
            NSString * date_time_string = [dateformat stringFromDate:_dateline];
            
            rv = PK11_SetPrivateKeyNickname(prvkey, [date_time_string UTF8String]);
            
            rv = PK11_SetPublicKeyNickname(pubkey, [date_time_string UTF8String]);
            
            
            CERTSubjectPublicKeyInfo *spki=NULL;
            
            /* Create info about public key */
            spki = SECKEY_CreateSubjectPublicKeyInfo(pubkey);
            
            if (NULL == spki) {
                SECKEY_DestroyPrivateKey(prvkey);
                SECKEY_DestroyPublicKey(pubkey);
                CERT_DestroyName(subject);
                PK11_FreeSlot(slot);
                NSS_Shutdown();
                
                setLastErrInfo(EStateErrorGenPriKey);
                return EStateErrorGenPriKey;
            }
            
            /* Generate certificate request */
            
            CERTCertificateRequest *cr;
            
            cr = CERT_CreateCertificateRequest(subject, spki, NULL);
            
            if (NULL == cr) {
                SECKEY_DestroySubjectPublicKeyInfo(spki);
                SECKEY_DestroyPrivateKey(prvkey);
                SECKEY_DestroyPublicKey(pubkey);
                CERT_DestroyName(subject);
                PK11_FreeSlot(slot);
                NSS_Shutdown();
                
                setLastErrInfo(EStateErrorGenCertReq);
                return EStateErrorGenCertReq;
            }
            
            
            SECKEY_DestroySubjectPublicKeyInfo(spki);
            
            
            PRArenaPool *arena = NULL;
            
            arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
            
            void *extHandle = NULL;
            
            extHandle = CERT_StartCertificateRequestAttributes(cr);
            
            CERT_FinishExtensions(extHandle);
            CERT_FinishCertificateRequestAttributes(cr);
            
            SECItem *encoding;
            
            encoding = SEC_ASN1EncodeItem(arena, NULL, cr,
                                          SEC_ASN1_GET(CERT_CertificateRequestTemplate));
            CERT_DestroyCertificateRequest(cr);
            
            SECOidTag signAlgTag;
            
            SECOidTag   hashAlgTag      = SEC_OID_UNKNOWN;
            
            signAlgTag = SEC_GetSignatureAlgorithmOidTag(keytype, hashAlgTag);
            
            SECItem certReqDER = { siBuffer, NULL, 0 };
            
            rv = SEC_DerSignData(arena, &certReqDER, encoding->data, encoding->len,
                                 prvkey, signAlgTag);
            
            if (SECSuccess != rv) {
                PORT_FreeArena (arena, PR_FALSE);
                CERT_DestroyName(subject);
                PK11_FreeSlot(slot);
                NSS_Shutdown();
                
                setLastErrInfo(EStateErrorSignData);
                return EStateErrorSignData;
            }
            
            * str_cert_req = [GTMBase64 stringByEncodingBytes:certReqDER.data length:certReqDER.len];
            
            PORT_FreeArena (arena, PR_FALSE);
            
            if (prvkey) {
                SECKEY_DestroyPrivateKey(prvkey);
            }
            if (pubkey) {
                SECKEY_DestroyPublicKey(pubkey);
            }
            
        }
            
            break;
        case ecKey:
        {
            
#ifdef NSS_ENABLE_ECC
            void             * params;
            SECKEYPrivateKey *prvkey = NULL;
            SECKEYPublicKey *pubkey = NULL;
            
            rv = PK11_CheckUserPassword(slot, s_user_pin_data);
            
            if (SECSuccess != rv) {
                CERT_DestroyName(subject);
                PK11_FreeSlot(slot);
                NSS_Shutdown();
                
                setLastErrInfo(EStateErrorPIN);
                return EStateErrorPIN;
            }
            
            if ((params = (void *) getECParams("nistp256SM2")) == NULL)
                return EStateFailure;
            
            prvkey = PK11_GenerateKeyPair(slot, CKM_EC_KEY_PAIR_GEN, params, &pubkey,
                                          PR_TRUE /*isPerm*/, PR_TRUE /*isSensitive*/,
                                          NULL);
            
            
            
            
            unsigned char dataIN[256];
            unsigned char dataEn[256];
//            unsigned char dataDe[256];
//            
//            memset(dataIN, 0, 256);
//            memcpy(dataIN, "1234567890", 10);
//            
//            memset(dataEn, 0, 256);
//            memset(dataDe, 0, 256);
//            
//            
//            int outLen = SECKEY_PublicKeyStrength(pubkey);
//            
//            SECStatus rv11 = PK11_PubEncryptRaw(pubkey, dataEn, dataIN, outLen, NULL);
//            
//            SECStatus rv22 = PK11_PubDecryptRaw(prvkey,  dataDe, (unsigned *)&outLen,outLen, dataEn, outLen);
//            
            
            
            
            SECItem sig;
            SECItem hash;
            
            sig.data = dataIN;
            sig.len = 256;
            
            hash.len = 16;
            hash.data = dataEn;
            
            
            SECStatus rv1 = PK11_Sign(prvkey, &sig, &hash);
            SECStatus rv2 = PK11_Verify(pubkey, &sig, &hash, NULL);
            
            
            
            SECITEM_FreeItem((SECItem *)params, PR_TRUE);
            
            
            
            if (NULL == prvkey)
            {
                CERT_DestroyName(subject);
                PK11_FreeSlot(slot);
                NSS_Shutdown();
                
                setLastErrInfo(EStateErrorGenPriKey);
                return EStateErrorGenPriKey;
            }
            
            
            time_t now;
            time(&now);
            
            NSDate *_dateline = [NSDate dateWithTimeIntervalSince1970:now];
            NSDateFormatter *dateformat=[[NSDateFormatter alloc] init];
            [dateformat setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
            NSString * date_time_string = [dateformat stringFromDate:_dateline];
            
            rv = PK11_SetPrivateKeyNickname(prvkey, [date_time_string UTF8String]);
            
            rv = PK11_SetPublicKeyNickname(pubkey, [date_time_string UTF8String]);
            
            
            CERTSubjectPublicKeyInfo *spki=NULL;
            
            /* Create info about public key */
            spki = SECKEY_CreateSubjectPublicKeyInfo(pubkey);
            
            if (NULL == spki) {
                SECKEY_DestroyPrivateKey(prvkey);
                SECKEY_DestroyPublicKey(pubkey);
                CERT_DestroyName(subject);
                PK11_FreeSlot(slot);
                NSS_Shutdown();
                
                setLastErrInfo(EStateErrorGenPriKey);
                return EStateErrorGenPriKey;
            }
            
            /* Generate certificate request */
            
            CERTCertificateRequest *cr;
            
            cr = CERT_CreateCertificateRequest(subject, spki, NULL);
            
            if (NULL == cr) {
                SECKEY_DestroySubjectPublicKeyInfo(spki);
                SECKEY_DestroyPrivateKey(prvkey);
                SECKEY_DestroyPublicKey(pubkey);
                CERT_DestroyName(subject);
                PK11_FreeSlot(slot);
                NSS_Shutdown();
                
                setLastErrInfo(EStateErrorGenCertReq);
                return EStateErrorGenCertReq;
            }
            
            
            SECKEY_DestroySubjectPublicKeyInfo(spki);
            
            
            PRArenaPool *arena = NULL;
            
            arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
            
            void *extHandle = NULL;
            
            extHandle = CERT_StartCertificateRequestAttributes(cr);
            
            CERT_FinishExtensions(extHandle);
            CERT_FinishCertificateRequestAttributes(cr);
            
            SECItem *encoding;
            
            encoding = SEC_ASN1EncodeItem(arena, NULL, cr,
                                          SEC_ASN1_GET(CERT_CertificateRequestTemplate));
            CERT_DestroyCertificateRequest(cr);
            
            SECOidTag signAlgTag;
            
            SECOidTag   hashAlgTag      = SEC_OID_UNKNOWN;
            
            signAlgTag = SEC_GetSignatureAlgorithmOidTag(keytype, hashAlgTag);
            
            SECItem certReqDER = { siBuffer, NULL, 0 };
            
            rv = SEC_DerSignData(arena, &certReqDER, encoding->data, encoding->len,
                                 prvkey, signAlgTag);
            
            if (SECSuccess != rv) {
                PORT_FreeArena (arena, PR_FALSE);
                CERT_DestroyName(subject);
                PK11_FreeSlot(slot);
                NSS_Shutdown();
                
                setLastErrInfo(EStateErrorSignData);
                return EStateErrorSignData;
            }
            
            * str_cert_req = [GTMBase64 stringByEncodingBytes:certReqDER.data length:certReqDER.len];
            
            PORT_FreeArena (arena, PR_FALSE);
            
            if (prvkey) {
                SECKEY_DestroyPrivateKey(prvkey);
            }
            if (pubkey) {
                SECKEY_DestroyPublicKey(pubkey);
            }
            
#endif
        }
            break;
        default:
            break;
    }
    
    
    if (subject) {
        CERT_DestroyName(subject);
    }
    if (slot) {
        PK11_FreeSlot(slot);
    }
    
    rv = NSS_Shutdown();
    
    return EStateSuccess;
}


int genCSRWithCertID( OUT NSString * * str_cert_req, IN const NSString * str_dev_name, IN const NSString * str_name, IN const NSString * str_email, IN const NSString * str_department, IN const NSString * str_unit, IN const NSString * str_cert_id)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    
    /*生成证书请求 需要登陆*/
    if (false == s_user_pin_flag)
    {
        setLastErrInfo(EStateErrorNeedLogin);
        return EStateErrorNeedLogin;
    }
    
    if (nil == str_cert_req) {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    if (nil == str_cert_id  || nil == s_array_cert_table)
    {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    if ([str_cert_id intValue] >= [s_array_cert_table count])
    {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    CERTName *  subject = 0;
    
    NSMutableString * strSubject = [[NSMutableString alloc] init];
    
    if (str_name && 0 < [str_name length]) {
        [strSubject appendFormat:@"CN=%@", str_name];
    }
    
    if (str_email && 0 < [str_email length])
    {
        [strSubject appendFormat:@", E=%@", str_email];
    }
    
    if (str_department && 0 < [str_department length])
    {
        [strSubject appendFormat:@", OU=%@", str_department];
    }
    
    if (str_unit && 0 < [str_unit length])
    {
        [strSubject appendFormat:@", O=%@", str_unit];
    }
    
    subject = CERT_AsciiToName([strSubject UTF8String]);
    
    
    if (NULL == subject) {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    CertInfoClass * info = [s_array_cert_table objectAtIndex:[str_cert_id intValue]];
    
    SECStatus rv = 0;
    
    /*初始化数据库*/
    rv = NSS_Initialize(GetSystemDBDir(),
                        "", "",
                        "secmod.db", 0);
    
    if (SECSuccess != rv) {
        setLastErrInfo(EStateErrorInitDB);
        return EStateErrorInitDB;
    }
    
    
    CERTCertDBHandle *certHandle;
    
    
    certHandle = CERT_GetDefaultCertDB();
    
    PK11SlotInfo * slot = PK11_GetInternalKeySlot();
    
    
    if (NULL == slot) {
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoSlot);
        return EStateErrorNoSlot;
    }
    
    rv = PK11_CheckUserPassword(slot, s_user_pin_data);
    
    if (SECSuccess != rv)
    {
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorPIN);
        return EStateErrorPIN;
    }
    
    CERTCertificate * cert = NULL;
    /*用nickname查找数据库证书*/
    
    const char * nickname = [info.m_nick_name UTF8String];
    
    cert = CERT_FindCertByNicknameOrEmailAddr(certHandle, nickname);
    
    if (NULL == cert) {
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoCert);
        return EStateErrorNoCert;
    }
    
    SECKEYPublicKey *  pubkey = CERT_ExtractPublicKey(cert);
    
    if (NULL == pubkey)
    {
        CERT_DestroyCertificate(cert);
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoPubKey);
        return EStateErrorNoPubKey;
    }
    
    
    SECKEYPrivateKey *prvkey = NULL;
    
    prvkey = PK11_FindKeyByAnyCert(cert, NULL);
    
    if (NULL == prvkey)
    {
        CERT_DestroyCertificate(cert);
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoPriKey);
        
        return EStateErrorNoPriKey;
    }
    
    
    CERTSubjectPublicKeyInfo *spki=NULL;
    
    /* Create info about public key */
    spki = SECKEY_CreateSubjectPublicKeyInfo(pubkey);
    
    if (NULL == spki) {
        SECKEY_DestroyPublicKey(pubkey);
        CERT_DestroyName(subject);
        CERT_DestroyCertificate(cert);
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorGenPriKey);
        return EStateErrorGenPriKey;
    }
    
    /* Generate certificate request */
    
    CERTCertificateRequest *cr;
    
    cr = CERT_CreateCertificateRequest(subject, spki, NULL);
    
    if (NULL == cr) {
        SECKEY_DestroySubjectPublicKeyInfo(spki);
        SECKEY_DestroyPublicKey(pubkey);
        CERT_DestroyName(subject);
        CERT_DestroyCertificate(cert);
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorGenCertReq);
        return EStateErrorGenCertReq;
    }
    
    
    SECKEY_DestroySubjectPublicKeyInfo(spki);
    
    
    PRArenaPool *arena = NULL;
    
    arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
    
    void *extHandle = NULL;
    
    extHandle = CERT_StartCertificateRequestAttributes(cr);
    
    CERT_FinishExtensions(extHandle);
    CERT_FinishCertificateRequestAttributes(cr);
    
    SECItem *encoding;
    
    encoding = SEC_ASN1EncodeItem(arena, NULL, cr,
                                  SEC_ASN1_GET(CERT_CertificateRequestTemplate));
    CERT_DestroyCertificateRequest(cr);
    
    SECOidTag signAlgTag;
    
    SECOidTag   hashAlgTag      = SEC_OID_UNKNOWN;
    
    signAlgTag = SEC_GetSignatureAlgorithmOidTag(pubkey->keyType, hashAlgTag);
    
    SECItem certReqDER = { siBuffer, NULL, 0 };
    
    rv = SEC_DerSignData(arena, &certReqDER, encoding->data, encoding->len,
                         prvkey, signAlgTag);
    
    if (SECSuccess != rv) {
        PORT_FreeArena (arena, PR_FALSE);
        
        CERT_DestroyCertificate(cert);
        CERT_DestroyName(subject);
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorSignData);
        return EStateErrorSignData;
    }
    
    * str_cert_req = [GTMBase64 stringByEncodingBytes:certReqDER.data length:certReqDER.len];
    
    PORT_FreeArena (arena, PR_FALSE);
    
    if (prvkey) {
        SECKEY_DestroyPrivateKey(prvkey);
    }
    if (pubkey) {
        SECKEY_DestroyPublicKey(pubkey);
    }
    
    
    if (cert)
    {
        CERT_DestroyCertificate(cert);
    }
    
    if (subject) {
        CERT_DestroyName(subject);
    }
    if (slot) {
        PK11_FreeSlot(slot);
    }
    
    rv = NSS_Shutdown();
    
    return EStateSuccess;
}


int importCert(IN const NSString * str_dev_name, IN const NSString * str_cert)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    
    /*生成证书请求 需要登陆*/
    if (false == s_user_pin_flag)
    {
        setLastErrInfo(EStateErrorNeedLogin);
        return EStateErrorNeedLogin;
    }
    
    if (nil == str_cert) {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    NSData * dataDe = [GTMBase64 decodeString:(NSString *)str_cert];
    
    if (nil == dataDe) {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    SECStatus rv = 0;
    
    /*初始化数据库*/
    rv = NSS_Initialize(GetSystemDBDir(),
                        "", "",
                        "secmod.db", 0);
    
    if (SECSuccess != rv) {
        
        setLastErrInfo(EStateErrorInitDB);
        return EStateErrorInitDB;
    }
    
    CERTCertDBHandle *certHandle;
    
    certHandle = CERT_GetDefaultCertDB();
    
    PK11SlotInfo * slot = PK11_GetInternalKeySlot();
    
    if (NULL == slot) {
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoSlot);
        return EStateErrorNoSlot;
    }
    
    CERTCertificate *cert = NULL;
    
    
    rv = PK11_CheckUserPassword(slot, (char *)s_user_pin_data);
    if (SECSuccess != rv)
    {
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorPIN);
        return EStateErrorPIN;
    }
    
    cert = CERT_DecodeCertFromPackage((char *)[dataDe bytes], [dataDe length]);
    
    if (NULL == cert)
    {
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorCert);
        return EStateErrorCert;
    }
    
    SECKEYPrivateKeyList * listPri = PK11_ListPrivKeysInSlot(slot, NULL,NULL);
    
    if (NULL == listPri) {
        CERT_DestroyCertificate (cert);
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoPriKey);
        return EStateErrorNoPriKey;
    }
    
    SECKEYPublicKey *  pubkey = CERT_ExtractPublicKey(cert);
    
    if (NULL == pubkey) {
        SECKEY_DestroyPrivateKeyList(listPri);
        CERT_DestroyCertificate (cert);
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoPubKey);
        return EStateErrorNoPubKey;
    }
    
    SECKEYPrivateKeyListNode *nPri = NULL;
    
    bool ok = false; // 是否有相对应的私钥
    
    for(nPri = PRIVKEY_LIST_HEAD(listPri);
        !PRIVKEY_LIST_END(nPri, listPri);
        nPri = PRIVKEY_LIST_NEXT(nPri))
        
    {
        char * nickname = PK11_GetPrivateKeyNickname(nPri->key);
        
        unsigned char dataIN[256];
        unsigned char dataEn[256];
        unsigned char dataDe[256];
        
        memset(dataIN, 0, 256);
        memcpy(dataIN, "1234567890", 10);
        
        memset(dataEn, 0, 256);
        memset(dataDe, 0, 256);
        
        int outLen = SECKEY_PublicKeyStrength(pubkey);
        
        
        SECItem sig;
        SECItem hash;
        
        sig.data = dataIN;
        sig.len = 256;
        
        hash.len = 16;
        hash.data = dataEn;
        
        
        SECStatus rv1 = PK11_Sign(nPri->key, &sig, &hash);
        SECStatus rv2 = PK11_Verify(pubkey, &sig, &hash, NULL);
        
        if (SECSuccess == rv1 && SECSuccess == rv2/* && 0 != outLen && 0 == memcmp(dataIN, dataDe, outLen)*/) {
            
            CERTCertificate * certOld = PK11_GetCertFromPrivateKey(nPri->key);
            
            while (NULL != certOld)
            {
                rv = SEC_DeletePermCertificate(certOld);
                certOld = PK11_GetCertFromPrivateKey(nPri->key);
            }
            
            rv =  PK11_ImportCert(slot, cert, nPri->key->pkcs11ID, nickname, PR_FALSE);
            
            if (SECSuccess != rv) {
                SECKEY_DestroyPublicKey(pubkey);
                SECKEY_DestroyPrivateKeyList(listPri);
                CERT_DestroyCertificate (cert);
                PK11_FreeSlot(slot);
                NSS_Shutdown();
                
                PORT_Free(nickname);
                
                setLastErrInfo(EStateErrorImportCert);
                
                return EStateErrorImportCert;
            }
            ok = true;
            
            break;
        }
        
        
        //        SECStatus rv1 = PK11_PubEncryptRaw(pubkey, dataEn, dataIN, outLen, NULL);
        //        SECStatus rv2 = PK11_PubDecryptRaw(nPri->key,  dataDe, (unsigned *)&outLen,outLen, dataEn, outLen);
        //
        //
        //        if (SECSuccess == rv1 && SECSuccess == rv2 && 0 != outLen && 0 == memcmp(dataIN, dataDe, outLen)) {
        //            rv =  PK11_ImportCert(slot, cert, nPri->key->pkcs11ID, nickname, PR_FALSE);
        //
        //            if (SECSuccess != rv) {
        //                SECKEY_DestroyPublicKey(pubkey);
        //                SECKEY_DestroyPrivateKeyList(listPri);
        //                CERT_DestroyCertificate (cert);
        //                PK11_FreeSlot(slot);
        //                NSS_Shutdown();
        //
        //                PORT_Free(nickname);
        //
        //                setLastErrInfo(EStateErrorImportCert);
        //
        //                return EStateErrorImportCert;
        //            }
        //            ok = true;
        //
        //            break;
        //        }
    }
    
    SECKEY_DestroyPublicKey(pubkey);
    SECKEY_DestroyPrivateKeyList(listPri);
    
    //    rv =  PK11_ImportCert(slot, cert, CK_INVALID_HANDLE, NULL, PR_FALSE);
    //    if (SECSuccess != rv) {
    //        CERT_DestroyCertificate (cert);
    //        PK11_FreeSlot(slot);
    //        NSS_Shutdown();
    //        setLastErrInfo(EStateErrorImportCert);
    //        return EStateErrorImportCert;
    //    }
    
    CERT_DestroyCertificate (cert);
    
    if (!ok)
    {
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorImportCert);
        return EStateErrorImportCert;
    }
    
    
    PK11_FreeSlot(slot);
    rv = NSS_Shutdown();
    
    return EStateSuccess;
}




int verifyPIN(IN const NSString * str_dev_name, IN const NSString * str_pwd, IN int i_retry_times)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    
    if (nil == str_pwd) {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    
    SECStatus rv = 0;
    
    /*初始化数据库*/
    rv = NSS_Initialize(GetSystemDBDir(),
                        "", "",
                        "secmod.db", 0);
    
    
    
    if (SECSuccess != rv) {
        setLastErrInfo(EStateErrorInitDB);
        return EStateErrorInitDB;
    }
    
    
    unsigned char data_value[256];
    
    unsigned int data_len = 255;
    
    memset(data_value, 0, data_len + 1);
    
    itrus_Password_Generator_User_Old(data_value, &data_len, (unsigned char *)[str_pwd UTF8String], strlen([str_pwd UTF8String]));

    
    PK11SlotInfo * slot = PK11_GetInternalKeySlot();
    
    if (slot) {
        if (PK11_NeedUserInit(slot)) {
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            setLastErrInfo(EStateErrorUninitPIN);
            return EStateErrorUninitPIN;
        }
    }
    
    rv = PK11_CheckUserPassword(slot, (char *)data_value);
    
    if (SECSuccess != rv)
    {
        s_user_pin_flag = false;
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorPIN);
        return EStateErrorPIN;
    }
    
    memcpy(s_user_pin_data, data_value, data_len + 1);
    s_user_pin_flag = true;
    
    PK11_FreeSlot(slot);
    NSS_Shutdown();
    return EStateSuccess;
}



int changePIN(IN const NSString * str_dev_name, IN const NSString * str_pwd_ori, IN const NSString * str_pwd_new)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    if (nil == str_pwd_ori || nil == str_pwd_new) {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    
    SECStatus rv = 0;
    
    /*初始化数据库*/
    rv = NSS_Initialize(GetSystemDBDir(),
                        "", "",
                        "secmod.db", 0);
    
    if (SECSuccess != rv) {
        setLastErrInfo(EStateErrorInitDB);
        return EStateErrorInitDB;
    }
    
    
    unsigned char data_value_old[256];
    unsigned int data_len_old = 255;
    
    unsigned char data_value_new[256];
    unsigned int data_len_new = 255;
    
    
    memset(data_value_old, 0, data_len_old + 1);
    
    itrus_Password_Generator_User_Old(data_value_old, &data_len_old, (unsigned char *)[str_pwd_ori UTF8String], strlen([str_pwd_ori UTF8String]));
    
    memset(data_value_new, 0, data_len_new + 1);
    
    itrus_Password_Generator_User_New(data_value_new, &data_len_new, (unsigned char *)[str_pwd_new UTF8String], strlen([str_pwd_new UTF8String]));
    
    
    PK11SlotInfo * slot = PK11_GetInternalKeySlot();
    
    if (slot) {
        if (PK11_NeedUserInit(slot)) {
            rv = PK11_InitPin(slot, (char*)NULL, (char *)data_value_new);
            if (rv != SECSuccess) {
                PK11_FreeSlot(slot);
                NSS_Shutdown();
                
                setLastErrInfo(EStateErrorInitPIN);
                return EStateErrorInitPIN;
            }
            else
            {
                itrus_Save_Info_User(NULL, 0);
            }
            
            
            
            PK11_FreeSlot(slot);
            NSS_Shutdown();
            
            return EStateSuccess;
        }
    }
    
    rv = PK11_CheckUserPassword(slot, (char *)data_value_old);
    if (SECSuccess != rv)
    {
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorPIN);
        return EStateErrorPIN;
    }
    
    rv = PK11_ChangePW(slot, (char *)data_value_old,
                       (char *)data_value_new);
    
    if (SECSuccess != rv)
    {
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateFailure);
        return EStateFailure;
    }
    else
    {
        itrus_Save_Info_User(NULL, 0);
    }
    
    s_user_pin_flag = false;
    
    PK11_FreeSlot(slot);
    NSS_Shutdown();
    return EStateSuccess;
}



int isRemovableDevice(OUT NSString * * str_dev_type, IN const NSString * str_dev_name)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    
    if (nil == str_dev_type) {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    * str_dev_type = @"on";
    
    return EStateSuccess;
}


// new interface add

int InitPIN(IN const NSString * str_pin_so ,IN const NSString * str_pin_usr)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
	CK_RV rv;
	CK_SLOT_ID_PTR pSlotList;
	CK_SLOT_ID slotID;
	CK_ULONG slotCount;
	CK_SESSION_HANDLE hSession;
    
    CK_FUNCTION_LIST_PTR pFunctionList;
    
    CK_C_INITIALIZE_ARGS_NSS initArgs;
    
    
    char *moduleSpec = NULL;
    char *configDir = GetSystemDBDir();
    char *dbPrefix = "";
    
    initArgs.CreateMutex = NULL;
    initArgs.DestroyMutex = NULL;
    initArgs.LockMutex = NULL;
    initArgs.UnlockMutex = NULL;
    initArgs.flags = CKF_OS_LOCKING_OK;
    moduleSpec = PR_smprintf("configdir='%s' certPrefix='%s' "
                             "keyPrefix='%s' secmod='secmod.db' flags= ",
                             configDir, dbPrefix, dbPrefix);
    initArgs.LibraryParameters = (CK_CHAR_PTR *) moduleSpec;
    initArgs.pReserved = NULL;
    
    unsigned char data_value[256];
    
    unsigned int data_len = 255;
    
    memset(data_value, 0, data_len + 1);
    
    itrus_Password_Generator_User_New(data_value, &data_len, (unsigned char *)[str_pin_usr UTF8String], strlen([str_pin_usr UTF8String]));
    
    rv = C_GetFunctionList(&pFunctionList);
    
    if (rv != CKR_OK) {
        setLastErrInfo(EStateFailure);
		return EStateFailure;
	}
    
	rv = pFunctionList->C_Initialize (&initArgs);
	if (rv != CKR_OK) {
        setLastErrInfo(EStateFailure);
		return EStateFailure;
	}
    
	//	C_GetSlotList:
	//	this function list all the slots in system, which contain tokens.
	//	(see "SlotFunctions" project). This call passes in a NULL on the second
	//	parameter. This returns  the actual slot count.
	rv = pFunctionList->C_GetSlotList (TRUE, NULL, &slotCount);
	if (rv != CKR_OK) {
        rv = pFunctionList->C_Finalize(NULL);
        setLastErrInfo(EStateFailure);
		return EStateFailure;
	}
    
	pSlotList = (CK_SLOT_ID_PTR) malloc (slotCount * sizeof(CK_SLOT_ID));
	
	//	C_GetSlotList:
	//the second call to actually gets the list of slots
	rv = pFunctionList->C_GetSlotList (TRUE, pSlotList, &slotCount);
	if (rv != CKR_OK) {
		free (pSlotList);
        rv = pFunctionList->C_Finalize(NULL);
        setLastErrInfo(EStateFailure);
		return EStateFailure;
	}

	//
	//	There may be more than 1 token in slots. However, for the sake of
	//	simplication, we only use 1 slot: The first slot.
	//
    
	slotID = pSlotList[1];

	//	C_OpenSession:
	//	Open a "Read & Write" session.
	//	(see the "SessionManagementFunctions" project for more details)
	rv = pFunctionList->C_OpenSession(	slotID,
                                      CKF_RW_SESSION | CKF_SERIAL_SESSION,
                                      NULL,
                                      NULL,
                                      &hSession );
	if (rv != CKR_OK) {
		free (pSlotList);
        rv = pFunctionList->C_Finalize(NULL);
        setLastErrInfo(EStateFailure);
		return EStateFailure;
	}
    
	//	C_Login:
	//	this function log an SO into the session
	//	(see "SessionManagementFunctions" project for the details of "Login")
	rv = pFunctionList->C_Login(hSession, CKU_SO, (unsigned char *)[str_pin_so UTF8String], strlen([str_pin_so UTF8String]));
	if (rv != CKR_OK) {
		free (pSlotList);
        rv = pFunctionList->C_CloseSession(hSession);
        rv = pFunctionList->C_Finalize(NULL);
        setLastErrInfo(EStateErrorPIN);
		return EStateErrorPIN;
	}
    

    
	//	C_InitPIN:
	//	After SO is logged in. we can init User PIN
	rv = pFunctionList->C_InitPIN(hSession, data_value, data_len);
	if (rv != CKR_OK) {
        free (pSlotList);
        rv = pFunctionList->C_Logout(hSession);
        rv = pFunctionList->C_CloseSession(hSession);
        rv = pFunctionList->C_Finalize(NULL);
        setLastErrInfo(EStateErrorPIN);
        return EStateErrorPIN;
	}
    else
    {
        itrus_Save_Info_User(NULL, 0);
    }
    
    rv = pFunctionList->C_Logout(hSession);
    rv = pFunctionList->C_CloseSession(hSession);
    rv = pFunctionList->C_Finalize(NULL);
    
    return EStateSuccess;
}


int SetPIN(IN const NSString * str_pwd_ori, IN const NSString * str_pwd_new, IN unsigned int i_usr_type)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    
	CK_RV rv;
	CK_SLOT_ID_PTR pSlotList;
	CK_SLOT_ID slotID;
	CK_ULONG slotCount;
	CK_SESSION_HANDLE hSession;
    
    CK_FUNCTION_LIST_PTR pFunctionList;
    
    CK_C_INITIALIZE_ARGS_NSS initArgs;
    
    
    char *moduleSpec = NULL;
    char *configDir = GetSystemDBDir();
    char *dbPrefix = "";
    
    initArgs.CreateMutex = NULL;
    initArgs.DestroyMutex = NULL;
    initArgs.LockMutex = NULL;
    initArgs.UnlockMutex = NULL;
    initArgs.flags = CKF_OS_LOCKING_OK;
    moduleSpec = PR_smprintf("configdir='%s' certPrefix='%s' "
                             "keyPrefix='%s' secmod='secmod.db' flags= ",
                             configDir, dbPrefix, dbPrefix);
    initArgs.LibraryParameters = (CK_CHAR_PTR *) moduleSpec;
    initArgs.pReserved = NULL;
    
    unsigned char data_value_old[256];
    unsigned int data_len_old = 255;
    
    unsigned char data_value_new[256];
    unsigned int data_len_new = 255;
    
    
    memset(data_value_old, 0, data_len_old + 1);
    
    itrus_Password_Generator_User_Old(data_value_old, &data_len_old, (unsigned char *)[str_pwd_ori UTF8String], strlen([str_pwd_ori UTF8String]));
    
    memset(data_value_new, 0, data_len_new + 1);
    
    itrus_Password_Generator_User_New(data_value_new, &data_len_new, (unsigned char *)[str_pwd_new UTF8String], strlen([str_pwd_new UTF8String]));
    
    rv = C_GetFunctionList(&pFunctionList);
    if (rv != CKR_OK) {
        setLastErrInfo(EStateFailure);
		return EStateFailure;
	}
    
	rv = pFunctionList->C_Initialize (&initArgs);
	if (rv != CKR_OK) {
        setLastErrInfo(EStateFailure);
		return EStateFailure;
	}
    
	//	C_GetSlotList:
	//	this function list all the slots in system, which contain tokens.
	//	(see "SlotFunctions" project). This call passes in a NULL on the second
	//	parameter. This returns  the actual slot count.
	rv = pFunctionList->C_GetSlotList (TRUE, NULL, &slotCount);
	if (rv != CKR_OK) {
        rv = pFunctionList->C_Finalize(NULL);
        setLastErrInfo(EStateFailure);
		return EStateFailure;
	}
    
	pSlotList = (CK_SLOT_ID_PTR) malloc (slotCount * sizeof(CK_SLOT_ID));
	
	//	C_GetSlotList:
	//the second call to actually gets the list of slots
	rv = pFunctionList->C_GetSlotList (TRUE, pSlotList, &slotCount);
	if (rv != CKR_OK) {
		free (pSlotList);
        rv = pFunctionList->C_Finalize(NULL);
        setLastErrInfo(EStateFailure);
		return EStateFailure;
	}
    
	//
	//	There may be more than 1 token in slots. However, for the sake of
	//	simplication, we only use 1 slot: The first slot.
	//
    
	slotID = pSlotList[1];
    
	//	C_OpenSession:
	//	Open a "Read & Write" session.
	//	(see the "SessionManagementFunctions" project for more details)
	rv = pFunctionList->C_OpenSession(	slotID,
                                      CKF_RW_SESSION | CKF_SERIAL_SESSION,
                                      NULL,
                                      NULL,
                                      &hSession );
	if (rv != CKR_OK) {
		free (pSlotList);
        rv = pFunctionList->C_Finalize(NULL);
        setLastErrInfo(EStateFailure);
		return EStateFailure;
	}
    
	//	C_Login:
	//	this function log an SO into the session
	//	(see "SessionManagementFunctions" project for the details of "Login")
    
    if (CKU_SO == i_usr_type) {
        rv = pFunctionList->C_Login(hSession, CKU_SO, (unsigned char *)[str_pwd_ori UTF8String], strlen([str_pwd_ori UTF8String]));
    }
    else
    {
        rv = pFunctionList->C_Login(hSession, CKU_USER, data_value_old, data_len_old);
    }
    

	if (rv != CKR_OK) {
		free (pSlotList);
        rv = pFunctionList->C_CloseSession(hSession);
        rv = pFunctionList->C_Finalize(NULL);
        setLastErrInfo(EStateErrorPIN);
		return EStateErrorPIN;
	}
    
	//	C_SetPIN:
	//	After SO is logged in. we can init C_SetPIN
    
    if (CKU_SO == i_usr_type) {
        rv = pFunctionList->C_SetPIN( hSession, (unsigned char *)[str_pwd_ori UTF8String], strlen([str_pwd_ori UTF8String]), (unsigned char *)[str_pwd_new UTF8String], strlen([str_pwd_new UTF8String]));
    }
    else
    {
        rv = pFunctionList->C_SetPIN( hSession, data_value_old, data_len_old, data_value_new, data_len_new);
    }

	
	if (rv != CKR_OK) {
        free (pSlotList);
        rv = pFunctionList->C_Logout(hSession);
        rv = pFunctionList->C_CloseSession(hSession);
        rv = pFunctionList->C_Finalize(NULL);
        setLastErrInfo(EStateErrorPIN);
        return EStateErrorPIN;
	}
    else
    {
        if (CKU_SO != i_usr_type) {
            itrus_Save_Info_User(NULL, 0);
        }
    }
    
    rv = pFunctionList->C_Logout(hSession);
    rv = pFunctionList->C_CloseSession(hSession);
    rv = pFunctionList->C_Finalize(NULL);
    
    return EStateSuccess;
}



int deleteCertBySerialNumber(IN const NSString * str_cert_serial_number)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    
    if (nil == str_cert_serial_number) {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    SECStatus rv = 0;
    
    NSMutableArray * array;
    
    rv = filterCert(&array, 0,0,0,0,0);
    
    NSString * str_nickname = nil;
    

    for (int i = 0; i < [array count]; i++) {
        CertInfoClass * info = [s_array_cert_table objectAtIndex:[[array objectAtIndex:i] intValue]];
        
        if (NSOrderedSame == [str_cert_serial_number compare:info.m_info.SerialNumber options:NSCaseInsensitiveSearch]) {
            str_nickname = info.m_nick_name;
            break;
        }
    }
    
    return deleteCertByNickname(str_nickname);
}


int deleteCertByNickname(IN const NSString * str_cert_nickname)
{
    int licenceState = checkLicenseState();
    
    if (EStateSuccess != licenceState) {
        return licenceState;
    }
    
    
    if (nil == str_cert_nickname) {
        setLastErrInfo(EStateErrorInvalidArg);
        return EStateErrorInvalidArg;
    }
    
    SECStatus rv = 0;
    const char * nickname = NULL;
    
    if (str_cert_nickname) {
        nickname = [str_cert_nickname UTF8String];
    }
    
    /*初始化数据库*/
    rv = NSS_Initialize(GetSystemDBDir(),
                        "", "",
                        "secmod.db", 0);
    
    if (SECSuccess != rv) {
        setLastErrInfo(EStateErrorInitDB);
        return EStateErrorInitDB;
    }
    
    
    CERTCertDBHandle *certHandle;
    
    
    certHandle = CERT_GetDefaultCertDB();
    
    PK11SlotInfo * slot = PK11_GetInternalKeySlot();
    
    
    if (NULL == slot) {
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoSlot);
        return EStateErrorNoSlot;
    }
    
    rv = PK11_CheckUserPassword(slot, s_user_pin_data);
    
    if (SECSuccess != rv)
    {
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorPIN);
        return EStateErrorPIN;
    }
    
    CERTCertificate * cert = NULL;
    /*用nickname查找数据库证书*/
    
    //                unsigned char sn_data[256] = {0};
    //
    //                unsigned int sn_len = [str_cert_serial_number length] / 2;
    //
    //                for (int i = 0; i < sn_len; i++) {
    //                    sn_data[i] += CHAR_TO_16(*([str_cert_serial_number UTF8String] + i * 2)) * 16;
    //                    sn_data[i] += CHAR_TO_16(*([str_cert_serial_number UTF8String] + i * 2 + 1));
    //                }
    //
    //                for (int i = 0; i < sn_len; i++) {
    //                    printf("%02X", sn_data[i]);
    //                }
    
    cert = CERT_FindCertByNickname(certHandle, nickname);
    
    if (NULL == cert) {
        PK11_FreeSlot(slot);
        NSS_Shutdown();
        
        setLastErrInfo(EStateErrorNoCert);
        return EStateErrorNoCert;
    }
    
    SECKEYPrivateKey * prvkey = PK11_FindKeyByAnyCert(cert, NULL);
    SECKEYPublicKey * pubkey = NULL;
    
    SECKEYPublicKeyList * listPub = PK11_ListPublicKeysInSlot(slot, NULL);
    
    SECKEYPublicKeyListNode *nPub;
    
    bool pubExist = false;
    
    for(nPub = PUBKEY_LIST_HEAD(listPub);
        !PUBKEY_LIST_END(nPub, listPub);
        nPub = PUBKEY_LIST_NEXT(nPub))
    {
        char * pub_nickname = PK11_GetPublicKeyNickname(nPub->key);
        
        if (0 == strcmp(pub_nickname, nickname + strlen("NSS Certificate DB:"))) {
            pubExist = true;
            break;
        }
    }
    
    
    if(pubExist)
    {
        pubkey = SECKEY_CopyPublicKey(nPub->key);
        rv = PK11_DeleteTokenPublicKey(pubkey);
        pubkey = NULL;
    }
    
    if(prvkey)
    {
        rv = PK11_DeleteTokenPrivateKey(prvkey, TRUE);
        prvkey = NULL;
    }
    
    if (cert)
    {
        rv = SEC_DeletePermCertificate(cert);
    }
    
    CERT_DestroyCertificate (cert);
    
    SECKEY_DestroyPublicKeyList(listPub);
    
    cert = NULL;
    
    PK11_FreeSlot(slot);
    NSS_Shutdown();
    
    return EStateSuccess;
    
}

/*
 功能名称:  验证LICENSE
 函数名称:  verifyLicense
 输入参数:  license名称 char *
 license值  char *
 输出参数:
 返回值:   成功：0
 失败：错误码
 功能描述: 验证LICENSE
 */
int verifyLicense(const char * str_license_name, const char * str_license_value);


/*
 功能名称:  设置LICENSE
 函数名称:  setLicense
 输入参数:  license名称 char *
 license值 char *
 输出参数:
 返回值:   -1:license 不成功  1:license 测试license 0:正式license
 功能描述: 设置LICENSE 如果LICENSE值与app名称相同则为测试LICENSE
 */
int setLicense(NSString * str_license_value);

/*
 功能名称:  生成LICENSE
 函数名称:  genLicense
 输入参数:  license名称 char *
 
 输出参数:  license值  char *
 返回值:   成功：0
 失败：错误码
 功能描述: 验证LICENSE
 */
int genLicense(const char * str_license_name, char * str_license_value);


/*
 功能名称:  检测LICENSE状态
 函数名称:  checkLicenseState
 输入参数:
 输出参数:  状态
 返回值:   成功：0
 失败：错误码
 功能描述: 设置LICENSE
 */

int checkLicenseState();

int genLicense(const char * str_license_name, char * str_license_value)
{
    int iRet = 0;
    int hashlen1 = 0;
    int hashlen2 = 0;
    int hashOid1 = SEC_OID_SHA1;
    int hashOid2 = SEC_OID_MD5;
    
    hashlen1 = HASH_ResultLenByOidTag(hashOid1);
    hashlen2 = HASH_ResultLenByOidTag(hashOid2);
    
    char dataSrc[MAX_BUFFER_LEN] = {0};
    unsigned char dataDstSHA1[MAX_BUFFER_LEN]= {0};
    unsigned char dataDstMD5itrus[MAX_BUFFER_LEN]= {0};
    unsigned char dataDstMD5wintrust[MAX_BUFFER_LEN]= {0};
    
    unsigned char dataDstEnd[MAX_BUFFER_LEN]= {0};
    
    strcpy(dataSrc, "itrus");
    strcat(dataSrc, str_license_name);

    iRet = SHA1_HashBuf(dataDstSHA1,(unsigned char *)dataSrc, strlen(dataSrc));
    MD5_HashBuf(dataDstMD5itrus,dataDstSHA1, hashlen1);
    MD5_HashBuf(dataDstMD5wintrust,(unsigned char *)"wintrust", strlen("wintrust"));
    
    for (int i = 0; i < hashlen2; i++) {
        dataDstEnd[i] = dataDstMD5itrus[i]^dataDstMD5wintrust[i];
    }
    
    
    for (int i = 0; i < hashlen2/2; i++) {
        dataDstEnd[i] = dataDstEnd[i]^dataDstEnd[hashlen2/2 + i];
    }
    
//    for (int i = 0; i < hashlen2/4; i++) {
//        dataDstEnd[i] = dataDstEnd[i]^dataDstEnd[hashlen2/4 + i];
//    }
    
    
    for (int k = 0; k < hashlen2/2; k++) {
        sprintf(str_license_value + 2 * k, "%02X", dataDstEnd[k]);
    }
    
    return 0;
    
}


int verifyLicense(const char * str_license_name, const char * str_license_value)
{
    int iRet = 0;
    
    char data_value[MAX_BUFFER_LEN] = {0};
    
    iRet = genLicense(str_license_name, data_value);
    
    if (0 == strcmp(data_value, str_license_value)) {
        return EStateSuccess;
    }
    else
    {
        setLastErrInfo(EStateErrorLicenseVerify);
        return EStateErrorLicenseVerify;
    }
    
    return EStateSuccess;
}


int setLicense(NSString * str_license_value)
{
    if (nil == str_license_value) {
        return EStateErrorInvalidArg;
    }
    
    if (0 == [str_license_value length]) {
        return EStateErrorInvalidArg;
    }
    
    NSDictionary* infoDict =[[NSBundle mainBundle] infoDictionary];
    NSString*appName =[infoDict objectForKey:@"CFBundleDisplayName"];
    
    NSString * str_license_name = appName;
    
    if (0 == strcmp([str_license_name UTF8String], [str_license_value UTF8String]))
	{
		s_license_ok = 1;
		return 1;
	}
    
    int iRet = verifyLicense([str_license_name UTF8String], [str_license_value UTF8String]);
    
    if (0 == iRet) {
        //itrus_Save_Info_License(str_license_name, str_license_value);
		s_license_ok = 0;
    }
    setLastErrInfo(iRet);
    return iRet;
}

#if !defined(NSS_FOR_IOS)

#else
#import "NoticeTimer.h"
static NoticeTimer * s_notice_timer = nil;
#endif

int checkLicenseState()
{
    if(0 == s_license_ok)
    {
#if !defined(NSS_FOR_IOS)
        
#else
        if (nil != s_notice_timer)
        {
            [s_notice_timer endTimer];
            
            s_notice_timer = nil;
        }
#endif
        return EStateSuccess;
    }
    else if(1 == s_license_ok)
    {
#if !defined(NSS_FOR_IOS)
        
#else
        if (nil == s_notice_timer)
        {
            s_notice_timer = [[NoticeTimer alloc] init];
            
            [s_notice_timer startTimer:10 * 60 withTimeRemain:2];
        }
#endif
        
	    return EStateSuccess;
    }
	else
	{
		return EStateErrorLicenseNotExist;
	}
}




